<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>计算机组成原理 - 程序的链接，装载和执行 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">计算机组成原理 - 程序的链接，装载和执行</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">计算机组成原理 - 程序的链接，装载和执行</h1><div class="post-meta">2020-10-18<span> | </span><span class="category"><a href="/categories/Big-Back-End/">Big-Back-End</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF-%E6%A0%BC%E5%BC%8F%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">ELF 格式和静态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%EF%BC%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">程序装载（内存分配优化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>本文打算从 ELF文件格式静态链接，程序装载，动态链接三个方面来分析一下，程序如何链接，装载和执行的。</p>
<span id="more"></span>

<p>当程序比如 C 语言程序，编译成汇编代码，在通过汇编器编译成机器码后，会生成一个或多个目标文件，这时 CPU 还不能直接执行，需要通过链接器（Linker）把多个目标文件以及各种函数库链接起来，生成一个可执行文件。然后 CPU 在通过装载器（Loader）把可执行文件装载到内存中，进而从内存里读取执行和数据，来开始真正执行程序。</p>
<p><img src="https://static001.geekbang.org/resource/image/99/a7/997341ed0fa9018561c7120c19cfa2a7.jpg" alt="程序如何执行"></p>
<h2 id="ELF-格式和静态链接"><a href="#ELF-格式和静态链接" class="headerlink" title="ELF 格式和静态链接"></a>ELF 格式和静态链接</h2><p>ELF（Execuatable and Linkable File Format）可执行和可链接文件格式。</p>
<p>简单来讲，正是因为 ELF 格式文件的存在，使得装载器无需考虑地址跳转等问题，直接解析该 ELF 格式文件，把对应指令和数据，加载到内存供 CPU 执行即可。</p>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来，里面不仅有汇编指令，还有以下一些数据：</p>
<ul>
<li>文件头: 表示文件基本属性。（是否可执行，CPU，操作系统是啥等）。</li>
<li>.text Section: 代码段或者指令段，用来保存程序的代码和指令。</li>
<li>.data Section: 数据段（Data Section），用来保存程序里面设置好的初始化数据信息。</li>
<li>.rel.text Secion: 重定位表（Relocation Table），保留的是当前的文件里，哪些跳转地址其实是我们不知道的。</li>
<li>.symtab Section: 符号表（Symbol Table），保留当前文件里面定义的函数名称和对应地址的地址簿。</li>
</ul>
<p>那么 ELF 格式文件具体如何生成的呢？</p>
<ul>
<li>首先链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。</li>
<li>然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。</li>
<li>最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。</li>
</ul>
<p>这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p>
<h2 id="程序装载（内存分配优化）"><a href="#程序装载（内存分配优化）" class="headerlink" title="程序装载（内存分配优化）"></a>程序装载（内存分配优化）</h2><p>装载器加载指令到内存，CPU 逐条执行。这里涉及到内存的分配，至少要满足以下两点：</p>
<ol>
<li><p>可执行程序加载后占用的内存空间应该是连续的</p>
</li>
<li><p>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。</p>
</li>
</ol>
<p>很容易想到可以做一个映射关系，在内存里找一段连续的内存空间，分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令的物理地址做一个映射。</p>
<p>实际上就是<strong>虚拟内存地址</strong>和<strong>物理内存地址</strong>的映射关系。我们只需要关心虚拟内存地址，程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。</p>
<p>这种虚拟内存和物理内存映射的方法也称为分段，他有个不足之处，即<strong>内存碎片</strong>。</p>
<p>内存碎片导致即使有内存，但因不连续而无法充分利用，即程序装载不进来。当然可以解决，即采用 <strong>内存交换</strong>。先将最后几个程序写入硬盘，然后加载当前程序，最后再将写入硬盘的程序读到内存。Linux swap 硬盘分区，就是专门给 Linux 操作系统进行内存交换用的。</p>
<p>虚拟内存、分段，再加上内存交换，已经解决了计算机同时装载运行很多个程序的问题，这三者的组合仍然会遇到一个性能瓶颈。硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p>
<p>为了解决这个问题，采用了内存分页技术。和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小。在 Linux 下，每一页我们通常只设置成 4KB。</p>
<p>当内存空间不够，我们需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，这样一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，更不会让整个机器被内存交换的过程给卡住。</p>
<p>当返回其它程序，操作系统发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的缺页错误（Page Fault），操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。</p>
<p>这种方式，使得我们可以运行那些远大于我们实际物理内存的程序。同时，这样一来，任何程序都不需要一次性加载完所有指令和数据，只需要加载当前需要用到就行了。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>程序装载到内存，根本的问题都是围绕内存不够用，如果我们能够让同样功能的代码，在不同的程序里面，共享一份内存空间呢，不就能节省内存了吗。</p>
<p>这个思路就引入一种新的链接方法，叫作动态链接（Dynamic Link）。相应的，我们之前说的合并代码段的方法，就是静态链接（Static Link）。</p>
<p>在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的共享库（Shared Libraries）。</p>
<p>不过，要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“地址无关”的。换句话说就是，这段代码，无论加载在哪个内存地址，都能够正常执行。</p>
<p>对于所有动态链接共享库的程序来讲，虽然我们的共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。</p>
<p>那么问题来了，我们要怎么样才能做到，动态共享库编译出来的代码指令，都是地址无关码呢？</p>
<p>我们只需要使用相对地址就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p>
<p>实际上，在进行 Linux 下的程序开发的时候，我们一直会用到各种各样的动态链接库。C 语言的标准库就在 1MB 以上。我们撰写任何一个程序可能都需要用到这个库，常见的 Linux 服务器里，&#x2F;usr&#x2F;bin 下面就有上千个可执行文件。通过动态链接这个方式，可以说彻底解决了这个问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序经过静态链接，程序装载之后，再通过动态链接把内存利用到了极致。这样，我们不仅能够做到代码在开发阶段的复用，也能做到代码在运行阶段的复用。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>计算机组成原理 - 程序的链接，装载和执行</p><p><span>Author: </span>mjd507</p><p><span>Date: </span>2020-10-18</p><p><span>Last Update: </span>2025-02-23</p><p><span>Blog Link: </span><a href="/2020/10/18/Computer-Organization-4/">https://mjd507.github.io/2020/10/18/Computer-Organization-4/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2020/10/18/Computer-Organization-4/"></i></span></p><p><span>Copyright Declaration: </span>This station is mainly used to sort out incomprehensible knowledge. I have not fully mastered most of the content. Please refer carefully.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/10/22/Computer-Organization-5/">计算机组成原理 - 二进制编码，电路</a><a class="next" href="/2020/10/12/Computer-Organization-3/">计算机组成原理 - 指令</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Back-End/">Big-Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://dashaun.com/posts/" title="DaShaun Carter" target="_blank">DaShaun Carter</a><ul></ul><a href="https://vladmihalcea.com/blog/" title="Vlad Mihalcea" target="_blank">Vlad Mihalcea</a><ul></ul><a href="https://www.danvega.dev/blog/" title="Dan Vega" target="_blank">Dan Vega</a><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>