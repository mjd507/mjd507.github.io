<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Linux 内核技术 - Page Cache 观测 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux 内核技术 - Page Cache 观测</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux 内核技术 - Page Cache 观测</h1><div class="post-meta">2020-12-28<span> | </span><span class="category"><a href="/categories/Big-Back-End/">Big-Back-End</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Cache-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">Page Cache 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Page-Cache"><span class="toc-number">2.</span> <span class="toc-text">为什么需要Page Cache</span></a></li></ol></div></div><div class="post-content"><p>Page Cache 管理不当，不仅会增加系统 I&#x2F;O 吞吐，还会引起业务性能抖动，我们在工作中遇到的一些场景比如：</p>
<ol>
<li>机器 load 飚高</li>
<li>机器 I&#x2F;O 吞吐飚高</li>
<li>业务响应时延出现较大的毛刺</li>
<li>业务平均响应时延明显增加</li>
</ol>
<p>这都很可能与 Page Cache 相关。</p>
<span id="more"></span>

<h2 id="Page-Cache-是什么"><a href="#Page-Cache-是什么" class="headerlink" title="Page Cache 是什么"></a>Page Cache 是什么</h2><p>先来看张图：<br><img src="https://static001.geekbang.org/resource/image/f3/1b/f344917f3cacd5bc06ae7c743a217f1b.png"></p>
<p>Page Cache 是内核管理的一块内存，不属于用户态。</p>
<p>如何观察Page Cache 呢？方式有很多，包括&#x2F;proc&#x2F;meminfo、free 、&#x2F;proc&#x2F;vmstat命令等，它们的内容其实是一致的。</p>
<p>我们以 &#x2F;proc&#x2F;meminfo 为例来看。less &#x2F;proc&#x2F;meminfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Buffers:            9000 kB</span><br><span class="line">Cached:           287204 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:           313512 kB</span><br><span class="line">Inactive:         212828 kB</span><br><span class="line">Active(anon):     225076 kB</span><br><span class="line">Inactive(anon):     5924 kB</span><br><span class="line">Active(file):      88436 kB</span><br><span class="line">Inactive(file):   206904 kB</span><br><span class="line">...</span><br><span class="line">Shmem:               860 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据上面数据，可以得到这样一个公式：</p>
<p><strong>Buffers + Cached + SwapCached  &#x3D;  Active(file) + Inactive(file) + Shmem + SwapCached</strong></p>
<p>而等式两边就是 Page Cache 包括的内容。等式右边这些项把 Buffers 和 Cached 做了一下细分，分为了 Active(file)，Inactive(file) 和 Shmem，我们从等式右边来分析。</p>
<p>Active(file) + Inactive(file) 是 File-backed page（与文件对应的内存页），我们平时用的 mmap() 内存映射方式和 buffered I&#x2F;O 来消耗的内存就属于这部分，最重要的是，这部分在真实的生产环境上最容易产生问题。</p>
<p>Shmem 是指匿名共享映射这种方式分配的内存（free 命令中 shared 这一项），比如 tmpfs（临时文件系统），这部分在真实的生产环境中产生的问题比较少。不过多关注。</p>
<p>SwapCached 是在打开了 Swap 分区后，把 Inactive(anon) + Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存。由于读入到内存后原来的 Swap File还 在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。这样做的目的也是为了减少I&#x2F;O。</p>
<p>建议你在生产环境中关闭Swap分区，因为Swap过程产生的I&#x2F;O会很容易引起性能抖动。</p>
<p>free 命令也可以查询 Page Cache，会根据 buff&#x2F;cache 判断存在多少Page Cache。 free 命令也是通过解析 &#x2F;proc&#x2F;meminfo 得出这些统计数据，开源的 <a target="_blank" rel="noopener" href="https://gitlab.com/procps-ng/procps">procfs</a> free.c 源码文件可以看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4# free -k</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        2047132      276744     1453236         860      317152     1630316</span><br><span class="line">Swap:       1048572           0     1048572</span><br></pre></td></tr></table></figure>

<p>通过 procfs 源码里面的 proc&#x2F;sysinfo.c 这个文件，你可以发现 buff&#x2F;cache 包括下面这几项：</p>
<p><strong>buff&#x2F;cache &#x3D; Buffers + Cached + SReclaimablei</strong></p>
<p>ps: 在做比较的过程中，一定要考虑到这些数据是动态变化的，而且执行命令本身也会带来内存开销，所以这个等式未必会严格相等，不过你不必怀疑它的正确性。</p>
<p>buff&#x2F;cache 是由 Buffers、Cached 和 SReclaimable 这三项组成的，它强调的是内存的可回收性，也就是说，可以被回收的内存会统计在这一项。其中 SReclaimable是 指可以被回收的内核内存，包括 dentry 和 inode 等，比较细节，不多说。</p>
<h2 id="为什么需要Page-Cache"><a href="#为什么需要Page-Cache" class="headerlink" title="为什么需要Page Cache"></a>为什么需要Page Cache</h2><p>我们看一个具体的例子。首先，我们来生成一个1G大小的新文件，然后把Page Cache清空，确保文件内容不在内存中，以此来比较第一次读文件和第二次读文件耗时的差异。具体的流程如下。</p>
<ol>
<li><p>先生成一个1G的文件：</p>
<p> dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;home&#x2F;dd.out bs&#x3D;4096 count&#x3D;$((1024*256))</p>
</li>
<li><p>清空 Page Cache，需要先执行一下 sync 来将脏页同步到磁盘再去 drop cache。</p>
<p> sync &amp;&amp; echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
</li>
<li><p>第一次读取文件的耗时如下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4# time cat /home/dd.out &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">real  0m1.774s</span><br><span class="line">user  0m0.020s</span><br><span class="line">sys 0m0.970s</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次读取文件的耗时如下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4# time cat /home/dd.out &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">real  0m0.212s</span><br><span class="line">user  0m0.020s</span><br><span class="line">sys 0m0.180s</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到，第二次读取文件的耗时远小于第一次的耗时，这是因为第一次是从磁盘来读取的内容，磁盘I&#x2F;O是比较耗时的，而第二次读取的时候由于文件内容已经在第一次读取时被读到内存了，所以是直接从内存读取的数据，内存相比磁盘速度是快很多的。这就是Page Cache存在的意义：减少I&#x2F;O，提升应用的I&#x2F;O速度。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>Linux 内核技术 - Page Cache 观测</p><p><span>Author: </span>Jiandong</p><p><span>Date: </span>2020-12-28</p><p><span>Last Update: </span>2025-02-23</p><p><span>Blog Link: </span><a href="/2020/12/28/Linux-Kernel-1/">https://mjd507.github.io/2020/12/28/Linux-Kernel-1/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2020/12/28/Linux-Kernel-1/"></i></span></p><p><span>Copyright Declaration: </span>Please refer carefully, most of the content I have not fully mastered.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/02/27/Linux-Perf-Cpu-1/">Linux 性能优化 - CPU 篇</a><a class="next" href="/2020/12/16/Computer-Organization-11/">计算机组成原理 - DMA</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Back-End/">Big-Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://dashaun.com/posts/" title="DaShaun Carter" target="_blank">DaShaun Carter</a><ul></ul><a href="https://develotters.com/" title="develotters" target="_blank">develotters</a><ul></ul><a href="https://vladmihalcea.com/blog/" title="Vlad Mihalcea" target="_blank">Vlad Mihalcea</a><ul></ul><a href="https://www.danvega.dev/blog/" title="Dan Vega" target="_blank">Dan Vega</a><ul></ul><a href="https://toomuchcoding.com/" title="Marcin Grzejszczak" target="_blank">Marcin Grzejszczak</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>