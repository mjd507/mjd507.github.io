<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>个人精炼的 Android 数据库框架 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">个人精炼的 Android 数据库框架</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">个人精炼的 Android 数据库框架</h1><div class="post-meta">2017-01-15<span> | </span><span class="category"><a href="/categories/Big-Back-End/">Big-Back-End</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">基本写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">2.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.</span> <span class="toc-text">注解的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text">实体的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TableManager-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.</span> <span class="toc-text">TableManager 的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dao-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.</span> <span class="toc-text">Dao 的定义</span></a></li></ol></div></div><div class="post-content"><p>CommonDao 总共只有 8 个类，核心类文件只有 5 个，客观来说，代码的可读性还是比较强的，但相比各大成熟的数据库框架，无论是性能或者可定制方面，亦或稳定性，都要逊色不少。算是一个学习的过程吧，最近一直在完善 CommonAndroid 基础库，刚把数据库部分弄好，决定把它单独作为一个模块来维护。欢迎各路大牛 star 或者 fork 来共同完善。数据库 <a target="_blank" rel="noopener" href="https://github.com/mjd507/CommonDao">CommonDao 地址</a>，Android 基本库 <a target="_blank" rel="noopener" href="https://github.com/mjd507/CommonAndroid">CommonAndroid 地址</a>。 </p>
<span id="more"></span>


<h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>源码里 test&#x2F;normal 目录下，有原始的数据库写法，这里就不贴了。现在需求假设是将一个用户的信息存进 Android 数据库，那么正常流程应该是这样：</p>
<blockquote>
</blockquote>
<ol>
<li>准备好 Person 的 JavaBeen</li>
<li>创建数据库，同事创建表。通过系统提供的 SQLiteOpenHelper 类来完成</li>
<li>创建数据库操作类，完成 增删改查 功能</li>
</ol>
<p>至此，就算完成了。你会发现非常简单，我们对数据库的操作只要一个 DBHelper 和一个 Dao 就完事了。确实是这样。对于很少使用到数据库的项目这样已经足够了，但是，如果项目中使用的数据库表很多，那么，我们就需要成倍的编写这些大体上算是重复的代码，相信你会感到恶心…… </p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面我们在对数据库操作，归根结底是通过 Person 这个 JavaBeen 对象 来与 SQLite 关系型数据库 交互。<strong>增改 —&gt; 将 Person 的值映射到 SQLite 数据库中，查 —&gt; 从 SQLite 中将取得的值转换成 Person。</strong></p>
<p>因为 JavaBeen 与数据库字段是对应的关系，所以，我们封装的时候就可以利用这个 Javabeen 对象。怎么利用呢？Person 这个类名 来作为数据库的表名，Person 里面的 字段 用来作为 数据库表的字段名。是不是很完美？</p>
<p>Person 类名好弄，属性怎么获取？ 这里就要用到反射。同时因为数据库有主键等，所以还需要定义一些注解来区分。</p>
<p>我们都知道反射会影响效率，那么就需要在一次反射后保存该 JavaBeen（表和字段）的信息。否则每次增删改查都需要反射。</p>
<h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>能定义的注解还不少，比如表名，字段名，字段属性（primaryKey，not null … ），但个人觉得除了定义列属性是否是主键外，其它的注解没有必要，就用 JavaBeen 的 类名 以及字段名，保持了一致性，找错也容易些。所以这里我最终将注解简化成 Column 一个文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述: 数据库列名</span></span><br><span class="line"><span class="comment"> * Created by mjd on 2017/1/7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为主键 默认不是主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实体的定义"><a href="#实体的定义" class="headerlink" title="实体的定义"></a>实体的定义</h2><p>这里实体需要分开，包括 JavaBeen 和 它里面的 成员变量，他们对应于数据库的 表 和 字段 。我们的目的是 用 Java 语句 动态的生成 数据库 表语句。这个表语句是由 表名 + 字段类型 + 字段名称 来拼接的。</p>
<p>所以我们的第一步 包装 成员变量，使之可以提供 数据名称 和 数据名称。因为 成员变量 对应于 数据库的 字段，也就是栏目 Column，所以我这里类名取之为 ColumnEntity ，但是不要误读，它里面的方法都是针对 成员变量。</p>
<p>先看我定义的 ColumnEntity 的 构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ColumnEntity(Field field) &#123;</span><br><span class="line">    <span class="keyword">this</span>.field = field;</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置访问权限</span></span><br><span class="line">    <span class="keyword">this</span>.name = field.getName();</span><br><span class="line">    <span class="keyword">this</span>.primaryKey = field.isAnnotationPresent(Column.class) &amp;&amp; field.getAnnotation(Column.class).primaryKey();</span><br><span class="line">    <span class="keyword">this</span>.type = field.getType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接受一个 Field 对象，JavaBeen 通过 类名.class.getDeclaredFields 可以获取该类所有的 Fields，有了这个 Field 就可以获取到 成员变量的 类型，名称，值。如果你在字段上使用了注解主键，这里也会获取到其值。好，现在仅需要提供一些 get 方法就可以 获取到 类型 + 名称 了。数据库操作离不开 增删改查，这里也提供了 为 成员变量 设值（对应查询） 和 获取值得方法（对应增改），这里尤其不要跟一般的搞混。</p>
<p>接下来就是包装 JavaBeen，因为里面的 成员变量 上面已经包装好了，所以，这里就方便多了。JavaBeen 对应的是数据库的 表的实体，也就是 Table，所以我这里就用 TableEntity了，再次提醒，不要误读，他针对的是 JavaBeen。来看下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableEntity</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    tableName = type.getSimpleName();</span><br><span class="line">    fields = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Field field : type.getDeclaredFields()) &#123;</span><br><span class="line">        fields.add(<span class="keyword">new</span> ColumnEntity(field));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接受一个 Class 对象，有了这个 Class，就可以使用它的名称来做表名，同时构建时 Class 内所有 field 的 ColumnEntity。至此建表的准备工作已经差不多了。接下来就是拼接建表语句了。根据字段的类型选择相应的数据库字段类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCreateTableStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(String.format(<span class="string">&quot;CREATE TABLE IF NOT EXISTS %s (&quot;</span>, tableName));</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ColumnEntity field : fields) &#123;</span><br><span class="line">        sb.append(field.getName()).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        sb.append(getSqlType(field)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        sb.append(index &lt; fields.size() - <span class="number">1</span> ? <span class="string">&quot;,&quot;</span> : <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSqlType</span><span class="params">(ColumnEntity field)</span> </span>&#123;</span><br><span class="line">    Class type = field.getType();</span><br><span class="line">    <span class="keyword">if</span> (field.isPrimaryKey()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;INTEGER PRIMARY KEY AUTOINCREMENT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(String.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TEXT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="keyword">int</span>.class) || type.equals(Integer.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;INT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="keyword">long</span>.class) || type.equals(Long.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;INT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="keyword">boolean</span>.class) || type.equals(Boolean.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;INT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="keyword">double</span>.class) || type.equals(Double.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FLOAT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok, 到这里，你只需调用 new TableEntity(Person.class).getCreateTableStatement(), 就可以自动的构建一个 SQL 语句，以 Person 为表名，Person 里面的字段 为数据库字段名的 SQL 语句。<br>** “CREATE TABLE IF NOT EXISTS Person (age INT,name TEXT)” **<br>是不是感觉一下子简化了不少生产力.</p>
<p>TableEntity 还有一个 将 JavaBeen 转换成 ContentValues 的 方法。原理就是遍历所有 field，获取其值，设置到 ContentValues 当中，以便于增改操作。</p>
<h2 id="TableManager-的定义"><a href="#TableManager-的定义" class="headerlink" title="TableManager 的定义"></a>TableManager 的定义</h2><p>为什么要定义一个 TableManager, 前面在思考的时候也提过，反射操作在效率上不太理想，而每次我们调用 new TableEntity(Class&lt;?&gt; clazz) 时，都会通过反射去获取每一个 成员变量，每一个成员变量也会通过反射来获取其相关信息。所以如果我们每次增删改查都去 new TableEntity(Person.class),效率太低了，所以出现了 TableManager，单例模式，使用 HashMap 保存 表实体。</p>
<p>表的创建 以及 查找 全部交由 TableManager 完成。这里提供了一个 register() 方法，你可以在应用开始的时候就去注册表的实体，这里还没有创建，但能为需要创建表时提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... types)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; type : types) &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(type) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LogUtils.d(TAG, <span class="string">&quot;表已注册过&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TableEntity m = <span class="keyword">new</span> TableEntity(type);</span><br><span class="line">        entities.put(type, m);</span><br><span class="line">        entityList.add(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TableEntity <span class="title">find</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entities.get(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 TableManager 创建表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTables</span><span class="params">(DbDao dao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TableEntity tableEntity : entityList) &#123;</span><br><span class="line">            dao.execute(tableEntity.getCreateTableStatement(), <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        LogUtils.e(TAG, <span class="string">&quot;表创建失败:&quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要传入一个 DbDao，其实就是数据库具体增删改查的类了。到这里，你也应该能猜到，要在数据库中创建表，必须先获得一个 DbDao 对象，DbDao 里面必须有 SQLiteOpenHelper。</p>
<h2 id="Dao-的定义"><a href="#Dao-的定义" class="headerlink" title="Dao 的定义"></a>Dao 的定义</h2><p>和你想象的一样，只有增删改查的方法，我们先来看下构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DbDao</span><span class="params">(Context context, DbParams params, DbUpdateListener dbUpdateListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mDbHelper = <span class="keyword">new</span> DbHelper(context, params.dbName, <span class="keyword">null</span>, params.dbVersion, dbUpdateListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DbDao 构造时需要 DbParams，这个是配置 数据库表名 以及 版本号 的类。目前存放在 DbManager 中。后面会介绍。另外一个参数 DbUpdateListener，这是一个接口，SQLiteOpenHelper 里的 onUpgrade() 方法里就是通过该接口将升级的处理回调给调用者。</p>
<p>构造方法里初始化了一个 DbHelper，其实就是 SQLiteOpenHelper，与普通的写法没有任何区别，SQLiteOpenHelper 里面 onCreate 的方法没有任何操作，因为创建表的操作已经交由 TableManager 去执行了, TableManager 里面会组织好 SQL 语句，交给 DbDao 的 execute()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql, String[] bindArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LogUtils.i(TAG, <span class="string">&quot;准备执行SQL[ &quot;</span> + sql + <span class="string">&quot; ]语句&quot;</span>);</span><br><span class="line">    mDb = mDbHelper.getWritableDatabase();</span><br><span class="line">    <span class="keyword">if</span> (mDb.isOpen()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(sql)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bindArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDb.execSQL(sql, bindArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mDb.execSQL(sql);</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.i(TAG, <span class="string">&quot;执行完毕！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;数据库未打开！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其余的增删改查方法就不贴出来了，想要研究或者改造的，欢迎去 GitHub 上 fork 或者 star，地址文章开头已经给了。</p>
<p>至此，CommonDao 的框架的核心部分都已经理了一理，剩余还有个 DbManager，这个是数据库统一配置的管理类，单例模式，提供了默认的以及可设置的数据库名称，版本号，以及升级的监听器。记得在 Application 的创建的时候初始化 该 DbManager。</p>
<p>期待你的加入，让 CommonDao 越来越健壮。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>个人精炼的 Android 数据库框架</p><p><span>Author: </span>mjd507</p><p><span>Date: </span>2017-01-15</p><p><span>Last Update: </span>2025-02-23</p><p><span>Blog Link: </span><a href="/2017/01/15/Android-Common-Dao/">https://mjd507.github.io/2017/01/15/Android-Common-Dao/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2017/01/15/Android-Common-Dao/"></i></span></p><p><span>Copyright Declaration: </span>This station is mainly used to sort out incomprehensible knowledge. I have not fully mastered most of the content. Please refer carefully.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/01/19/Network-States-Monitor/">关于应用中网络状态变化的一点思考</a><a class="next" href="/2017/01/08/Design-Pattern-Creational/">设计模式（创建型篇）</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Back-End/">Big-Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://dashaun.com/posts/" title="DaShaun Carter" target="_blank">DaShaun Carter</a><ul></ul><a href="https://develotters.com/" title="develotters" target="_blank">develotters</a><ul></ul><a href="https://vladmihalcea.com/blog/" title="Vlad Mihalcea" target="_blank">Vlad Mihalcea</a><ul></ul><a href="https://www.danvega.dev/blog/" title="Dan Vega" target="_blank">Dan Vega</a><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://www.techtalksweekly.io/" title="Tech Talks Weekly" target="_blank">Tech Talks Weekly</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>