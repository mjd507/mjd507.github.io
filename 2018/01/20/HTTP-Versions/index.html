<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>HTTP 协议各版本特性 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTP 协议各版本特性</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HTTP 协议各版本特性</h1><div class="post-meta">2018-01-20<span> | </span><span class="category"><a href="/categories/Network/">Network</a></span></div><div class="post-content"><p>HTTP 协议规定了客户端和服务器直接通信的规范，在网络模型中属于应用层，与开发者直接打交道，它本身也是基于 TCP 和 IP 协议来获取请求和响应，默认 HTTP 使用 TCP 的 80 端口，HTTPS 使用 443 端口。</p>
<p>HTTP 协议发展至今，已经经历过好几个版本。</p>
<span id="more"></span>

<h2 id="1-HTTP-x2F-0-9"><a href="#1-HTTP-x2F-0-9" class="headerlink" title="1. HTTP&#x2F;0.9"></a>1. HTTP&#x2F;0.9</h2><p>HTTP  1991 年发布的版本称为 HTTP&#x2F;0.9，是一个很简单的协议，只有一个 GET 方法，不支持多媒体内容的 MIME 类型、各种 HTTP 首部，或者版本号。该协议定义的初衷是为了获取简单的 HTML 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>

<p>服务端返回的响应内容格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure>

<p>它很快就被 HTTP&#x2F;1.0 取代了。</p>
<h2 id="2-HTTP-x2F-1-0"><a href="#2-HTTP-x2F-1-0" class="headerlink" title="2. HTTP&#x2F;1.0"></a>2. HTTP&#x2F;1.0</h2><p>1996，HTTP1.0 大大改进了之前的协议版本，并得到广泛使用。</p>
<p>HTTP&#x2F;0.9 只有 GET 方法，并且响应只能是 HTML，而 1.0 增加了更多的方法，比如 POST、HEAD；响应内容可以是图片视频文本或者其它类型。</p>
<p>1.0 的请求和响应都增加了版本号，头部信息，响应内容有状态码，引入字符集，授权认证，缓存，内容编码等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">Host:baidu.cn</span><br><span class="line">User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2)</span><br><span class="line">Accept:*/*</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type:text/plain</span><br><span class="line">Content-Length:123582</span><br><span class="line">Expires:Wed, 17 Jan 2018 14:37:52 GMT</span><br><span class="line">Server:tengine</span><br><span class="line"></span><br><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure>

<p>HTTP 1.0 一个主要的缺点就是，一个连接只能有一个请求，即每次请求都会重新建立一个 TCP 连接，TCP 建立连接需要三次握手，加上慢启动的特性，这将是很耗资源和性能的一个步骤，于是有些 HTTP 1.0 的实现版本，在请求头中添加了一个 <code>Connection:keep-alive</code>的标记，但是并没有被广泛支持。</p>
<p>因为 HTTP 1.0 的无连接，使得它也是一种无状态的协议。服务端没法维护客户端的信息，致使每个请求都得额外的去携带一些必要的信息，在连接很多的情况下，造成很多带宽的压力。</p>
<h2 id="3-HTTP-x2F-1-1"><a href="#3-HTTP-x2F-1-1" class="headerlink" title="3. HTTP&#x2F;1.1"></a>3. HTTP&#x2F;1.1</h2><p>1999 年，HTTP 1.1 发布了，相比 1.0，同样改进很大，也是现在用的最为广泛的一个版本。</p>
<h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive </span><br><span class="line">Keep-Alive: max=5, timeout=120</span><br></pre></td></tr></table></figure>

<p>HTTP 1.1 建立连接后，默认不会被断开，它允许多个有序的请求，客户端如果想要关闭连接，可以在最后一个请求的请求头中，加上 <code>Connection:close</code>来安全关闭这个连接。或者连接闲置达到指定时间，也可以自动断开连接。</p>
<h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>HTTP 1.1 引入了管道机制，即在一个连接上，客户端请求时不需要等待服务器响应后，才去发送下一个请求，客户端可以连续发送几个请求，服务端按照接受请求的顺序，依次把响应返回回来。</p>
<p>这里有一个问题，即客户端如何区分哪里是第一个响应的内容，哪里是下一个响应的内容呢？HTTP 1.1 为此添加了 <code>Content-Length</code>首部，用它来标记响应内容的结束位置，以及下一个响应内容的开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length:1234</span><br></pre></td></tr></table></figure>

<h3 id="3-3-分块传输"><a href="#3-3-分块传输" class="headerlink" title="3.3 分块传输"></a>3.3 分块传输</h3><p>使用 Content-Length 字段，前提是服务端必需要知道返回数据的长度，对于一些耗时的数据操作，服务端如果等所有操作都做完，才返回数据，效率非常不高，为此，采用了一种分块传输的处理方法，即产生一块数据，就发送一块。</p>
<p>具体的形式是，在响应头部返回 Transfer-Encoding 字段，表明数据是有未定的数据块组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:chunked</span><br></pre></td></tr></table></figure>

<p>每一个分块，都添加一个 <code>Content-Length</code>，当所有的数据块都传输完成时，范湖一个空的 chunked，<code>Content-Length</code> 设为 0，来表示传输完成。</p>
<h3 id="3-4-其它功能"><a href="#3-4-其它功能" class="headerlink" title="3.4 其它功能"></a>3.4 其它功能</h3><ul>
<li>新增 HTTP 方法，包括 PUT，PATCH，OPTIONS，DELETE。</li>
<li>HTTP 1.0 的 Header 中，Host 字段不是必需的，而 HTTP 1.1 必需。</li>
<li>客户端 cookies</li>
<li>摘要和代理认证</li>
<li>…</li>
</ul>
<h3 id="3-5-缺点"><a href="#3-5-缺点" class="headerlink" title="3.5 缺点"></a>3.5 缺点</h3><p>HTTP 1. 1 虽然可以持久连接，并引入了管道机制，但核心还是得<strong>按照顺序</strong>处理请求，返回响应内容。只有处理完一个回应，才会处理下一个回应，所以，如果第一个回应处理特别慢，那么后面的只能等待，这就是「对头堵塞」（Head-of-line blocking）。</p>
<p>开发者对这个问题，也提供了一些解决思路：</p>
<ul>
<li>减少请求：网页的样式和脚本合并，图片嵌入 css 中</li>
<li>多开持久连接：域名分片</li>
</ul>
<h2 id="4-SPDY"><a href="#4-SPDY" class="headerlink" title="4. SPDY"></a>4. SPDY</h2><p>2009年，谷歌宣布了自行研发的 SPDY 协议，主要解决传输速度和网络安全的问题。通过减少 HTTP 1.1 响应阻塞延时，来提高传输速度和性能。</p>
<p>SPDY 协议的特性包括复用，压缩，优先级，安全等。2015 年，Google 决定将 SPDY 合并到 HTTP 标准中，并命名为 HTTP &#x2F; 2。</p>
<h2 id="5-HTTP-x2F-2"><a href="#5-HTTP-x2F-2" class="headerlink" title="5. HTTP&#x2F;2"></a>5. HTTP&#x2F;2</h2><p>HTTP&#x2F;2 的特性是低延时传输，相比 HTTP 1. 1，主要在二进制协议，多路复用，头信息压缩，推送，请求优先级，安全等方面做了处理。</p>
<h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP&#x2F;2 将数据分成一个一个的帧，头帧存储元数据，数据帧存放数据，以及一些其他的帧。HTTP 1.1 的头信息是文本（ASCII 编码），数据体可以是文本，也可以是二进制，而 HTTP&#x2F;2 是一个彻底的二进制协议。</p>
<p>每个请求和响应，都有一个唯一的数据流 id，并且流数据都被划分为帧（二进制数据），每个帧都有这个唯一的流 id ，请求的流 id 为奇数，响应的流 id 为偶数。</p>
<h3 id="5-2-多路复用"><a href="#5-2-多路复用" class="headerlink" title="5.2 多路复用"></a>5.2 多路复用</h3><p>基于二进制协议，TCP 连接打开的时候，所有的数据流都可以传输，而不必打开额外的连接，并且因为有流 id 作为标记，多个响应数据不必要等待就可以直接传回来，解决了 HTTP 1.1 队头阻塞的问题。</p>
<h3 id="5-3-头部压缩"><a href="#5-3-头部压缩" class="headerlink" title="5.3 头部压缩"></a>5.3 头部压缩</h3><p>当我们不断地从同一个客户端访问服务器时，有很多重复的数据比如 cookie 数据，会在请求头上反复发送，增加带宽的使用以及延迟。为了解决这个问题，HTTP&#x2F;2 引入了头压缩。</p>
<p>头信息不是以 gzip 或 compress 等格式进行压缩，而是使用霍夫曼编码对文本值进行编码，所有头信息都会放在一张表里面，由客户端和服务器共同维护，随后的请求中省略任何重复的标题，使用一个索引号，服务端根据索引号从维护的表中引用它们。</p>
<h3 id="5-4-推送"><a href="#5-4-推送" class="headerlink" title="5.4 推送"></a>5.4 推送</h3><p>服务器推送是HTTP &#x2F; 2的另一个巨大功能，服务器知道客户端将要请求某个资源，可以将客户端推送到客户端，甚至不需要客户端询问它。</p>
<p>比如一个网页请求，里面有图片资源，脚本资源，现在服务端返回资源时，发现网页请求里面还有其他资源请求，就主动把其他请求的响应也返回回去了，减少了很多请求。</p>
<h3 id="5-5-请求优先级"><a href="#5-5-请求优先级" class="headerlink" title="5.5 请求优先级"></a>5.5 请求优先级</h3><p>客户端可以在请求头里添加一个优先级的信息来为流分配优先级。</p>
<p>如果流没有任何优先级信息，服务器则异步处理请求，即没有任何顺序。如果流有优先级，那么根据这个优先级信息，服务器决定需要给多少资源来处理哪个请求。</p>
<h3 id="5-6-安全"><a href="#5-6-安全" class="headerlink" title="5.6 安全"></a>5.6 安全</h3><p>对于 HTTP&#x2F;2 的安全性（通过TLS）是否强制进行了广泛的讨论。最后，决定不强制执行。但是，大多数供应商表示，只有在通过 TLS 使用 HTTP&#x2F;2 时才会支持。所以，尽管 HTTP&#x2F;2 不需要按规格加密，但是它默认情况下已经成为强制，通过 TLS 实现的 HTTP&#x2F;2 必须使用 TLS 1.2 版或更高版本，必须具有一定的最小密钥级别，需要临时密钥等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></p>
<p><a target="_blank" rel="noopener" href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/">Journey to HTTP&#x2F;2</a></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>HTTP 协议各版本特性</p><p><span>Author: </span>mjd507</p><p><span>Date: </span>2018-01-20</p><p><span>Last Update: </span>2024-01-27</p><p><span>Blog Link: </span><a href="/2018/01/20/HTTP-Versions/">https://mjd507.github.io/2018/01/20/HTTP-Versions/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2018/01/20/HTTP-Versions/"></i></span></p><p><span>Copyright Declaration: </span>This station is mainly used to sort out incomprehensible knowledge. I have not fully mastered most of the content. Please refer carefully.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/01/25/HTTP-Authorization/">HTTP 授权认证</a><a class="next" href="/2018/01/15/Use-netcat-to-transfer-TCP-UDP-Data/">使用 netcat 读写 TCP UDP 数据包</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Back-End/">Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/">Backend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-Algorithm/">Data Structure & Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Devops/">Devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Android/">Java & Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operation-System/">Operation System</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://daimajia.com/" title="代码家" target="_blank">代码家</a><ul></ul><a href="https://sivers.org/" title="Derek Sivers" target="_blank">Derek Sivers</a><ul></ul><a href="http://www.hugogu.cn/" title="Hugo Gu" target="_blank">Hugo Gu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>