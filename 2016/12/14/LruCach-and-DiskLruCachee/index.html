<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 中 Lru 缓存算法分析 | Cleaner</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 中 Lru 缓存算法分析</h1><a id="logo" href="/.">Cleaner</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 中 Lru 缓存算法分析</h1><div class="post-meta">Dec 14, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/12/14/LruCach-and-DiskLruCachee/" href="/2016/12/14/LruCach-and-DiskLruCachee/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">1.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LruCache"><span class="toc-number">2.</span> <span class="toc-text">LruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DiskLruCache"><span class="toc-number">3.</span> <span class="toc-text">DiskLruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非常棒的文章"><span class="toc-number">4.</span> <span class="toc-text">非常棒的文章</span></a></li></ol></div></div><div class="post-content"><p>Android 项目设计到大量 图片，文件时，都会使用到缓存技术，一般项目框架都会帮助我们封装好，我们只需要指定具体的缓存策略就可以了；缓存的策略或者说算法有很多种，比如 FIFO，FILO，LRU 等，本文主要分析一下 LruCache 以及 DiskLruCache。LruCache 在 Android 3.1 之后就出现在 Android 源码中了，DiskLruCache 得到官方推荐，但还未出现在源码里。<a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html" target="_blank" rel="external">查看 DiskLruCache.java 源码</a>，另外，JakeWharton 也有一份 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">DiskLruCache</a>，可以看看。</p>
<a id="more"></a>
<p>再看 LruCache 源码之前，有必要先了解一下这个类：LinkedHashMap。LruCache 内部就是使用这个 map 来维护缓存数据的。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>先看一个小栗子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">hashMap.put(<span class="string">"021"</span>, <span class="string">"shanghai"</span>);</div><div class="line">hashMap.put(<span class="string">"0512"</span>, <span class="string">"suzhou"</span>);</div><div class="line">hashMap.put(<span class="string">"010"</span>, <span class="string">"beijing"</span>);</div><div class="line"></div><div class="line">System.out.println(hashMap);</div><div class="line"></div><div class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">linkedHashMap.put(<span class="string">"021"</span>, <span class="string">"shanghai"</span>);</div><div class="line">linkedHashMap.put(<span class="string">"0512"</span>, <span class="string">"suzhou"</span>);</div><div class="line">linkedHashMap.put(<span class="string">"010"</span>, <span class="string">"beijing"</span>);</div><div class="line"></div><div class="line">System.out.println(linkedHashMap);</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="number">0512</span>=suzhou, <span class="number">021</span>=shanghai, <span class="number">010</span>=beijing&#125;</div><div class="line">&#123;<span class="number">021</span>=shanghai, <span class="number">0512</span>=suzhou, <span class="number">010</span>=beijing&#125;</div></pre></td></tr></table></figure></p>
<p>通过结果也可以猜到，LinkedHashMap 对内部存储的关系映射数据是有序的。我们看下它的源码，先看它内部的静态类 LinkedEntry ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * LinkedEntry adds nxt/prv double-links to plain HashMapEntry.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    LinkedEntry&lt;K, V&gt; nxt;</div><div class="line">    LinkedEntry&lt;K, V&gt; prv;</div><div class="line"></div><div class="line">    <span class="comment">/** Create the header entry */</span></div><div class="line">    LinkedEntry() &#123;</div><div class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">        nxt = prv = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Create a normal entry */</span></div><div class="line">    LinkedEntry(K key, V value, <span class="keyword">int</span> hash, HashMapEntry&lt;K, V&gt; next,</div><div class="line">                LinkedEntry&lt;K, V&gt; nxt, LinkedEntry&lt;K, V&gt; prv) &#123;</div><div class="line">        <span class="keyword">super</span>(key, value, hash, next);</div><div class="line">        <span class="keyword">this</span>.nxt = nxt;</div><div class="line">        <span class="keyword">this</span>.prv = prv;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，LinkedEntry 继承了 HashMapEntry，该 Entry 除了保存当前对象的引用外，还同时增加了两个 Entry，prv、nxt 来保存对前一个 和 后一个元素的引用。我们先看它存储数据的方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNewEntry</span><span class="params">(K key, V value, <span class="keyword">int</span> hash, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</div><div class="line"></div><div class="line">    <span class="comment">// Remove eldest entry if instructed to do so.</span></div><div class="line">    LinkedEntry&lt;K, V&gt; eldest = header.nxt;</div><div class="line">    <span class="keyword">if</span> (eldest != header &amp;&amp; removeEldestEntry(eldest)) &#123;</div><div class="line">        remove(eldest.key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Create new entry, link it on to list, and put it into table</span></div><div class="line">    LinkedEntry&lt;K, V&gt; oldTail = header.prv;</div><div class="line">    LinkedEntry&lt;K, V&gt; newTail = <span class="keyword">new</span> LinkedEntry&lt;K,V&gt;(</div><div class="line">            key, value, hash, table[index], header, oldTail);</div><div class="line">    table[index] = oldTail.nxt = header.prv = newTail;</div></pre></td></tr></table></figure></p>
<p>LinkedHashMap 里没有重写 put 方法，而是重写了 HashMap 的 put 方法调用的子方法 addNewEntry，提供了自己特有的双向链接列表的实现。再看下读取数据的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * This method is overridden to eliminate the need for a polymorphic</div><div class="line">     * invocation in superclass at the expense of code duplication.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        HashMapEntry&lt;K, V&gt; e = entryForNullKey;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (accessOrder)</div><div class="line">            makeTail((LinkedEntry&lt;K, V&gt;) e);</div><div class="line">        <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Replace with Collections.secondaryHash when the VM is fast enough (http://b/8290590).</span></div><div class="line">    <span class="keyword">int</span> hash = secondaryHash(key);</div><div class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</div><div class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</div><div class="line">            e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        K eKey = e.key;</div><div class="line">        <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</div><div class="line">            <span class="keyword">if</span> (accessOrder)</div><div class="line">                makeTail((LinkedEntry&lt;K, V&gt;) e);</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有一个 accessOrder，它是一个 布尔值，true 代表按访问顺序排，false 代表按插入顺序排，默认为 false，在构造函数里可以看到。如果打算按访问顺序（最先访问的在最前面）来保存元素，那么可以用它另一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    init();</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    init();</div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    header = <span class="keyword">new</span> LinkedEntry&lt;K, V&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>accessOrder 就为实现 Lru 算法的实现铺好了路。Lru 算法 ： 最少最近使用的对象，正好是基于访问顺序，利用 accessOrder 这一属性就非常简单了，下面就来看看 Lru 算法的实现。</p>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>先看构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用 LruCache 需提供一个缓存的最大的 size，当超过这个 size 就回收；另外，构造了一个 LinkedHashMap，accessOrder 传的值为 true，果然是按访问顺序排序。<br>LruCache 存储和读取的方法都是调用 LinkedHashMap 的方法，这里就不贴了。我们一般使用如下方法来构建一个 LruCache：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cacheSize = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 4MiB</span></div><div class="line">LruCache&lt;String, Bitmap&gt; bitmapCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getByteCount();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>创建 DiskLruCache：DiskLruCache 构造方法被私有化了，并提供了 open 方法来创建自身。该方法有四个参数，第一个是存储目录，可以选择 SD 卡上的缓存目录，如果想要应用卸载后，此目录数据一并删除，可以这样指定 /sdcard/Android/data/package_name/cache. 第二个参数是应用版本号，一般设为 1，当版本号发生改变时，会清除之前的缓存文件，但实际开发中作用不大，很多情况即使版本号改变了，之前的缓存还在，所以一般设为 1，第三个参数表示单个节点对应的数据的个数，一般也设为 1，第四个参数表示表示缓存的总大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// prefer to pick up where we left off</span></div><div class="line">        DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">        <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cache.readJournal();</div><div class="line">                cache.processJournal();</div><div class="line">                cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),</div><div class="line">                        IO_BUFFER_SIZE);</div><div class="line">                <span class="keyword">return</span> cache;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</div><div class="line"><span class="comment">//                System.logW("DiskLruCache " + directory + " is corrupt: "</span></div><div class="line"><span class="comment">//                        + journalIsCorrupt.getMessage() + ", removing");</span></div><div class="line">                cache.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// create a new empty cache</span></div><div class="line">        directory.mkdirs();</div><div class="line">        cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">        cache.rebuildJournal();</div><div class="line">        <span class="keyword">return</span> cache;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>DiskLruCache 在缓存对象的时候，如果 key 是一个 url，最好先用 key 的 md5 值作为新的 key 去缓存，主要是为了避免 url 中的特殊字符的影响。有了 key 之后，通过 edit(key) 方法获取一个 Editor 对象，在通过 这个 Editor 获得输出流，我们从网络下载文件时直接将获得的输入流写到这个 输出流当中，在通过 editor.commit() 方法将流写入文件系统，看下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</div><div class="line">    DiskLruCache.Editor editor = mDiskLrucache.edit(key);</div><div class="line">    <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</div><div class="line">        OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (downloadUrlToStream(url, outputStream)) &#123;</div><div class="line">            editor.commit();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            editor.abort();</div><div class="line">        &#125;</div><div class="line">        mDiskLrucache.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadUrlToStream</span><span class="params">(String url, OutputStream outputStream)</span> </span>&#123;</div><div class="line">    URL urlStr = <span class="keyword">null</span>;</div><div class="line">    HttpURLConnection conn = <span class="keyword">null</span>;</div><div class="line">    BufferedOutputStream out = <span class="keyword">null</span>;</div><div class="line">    BufferedInputStream in = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        urlStr = <span class="keyword">new</span> URL(url);</div><div class="line">        conn = (HttpURLConnection) urlStr.openConnection();</div><div class="line">        out = <span class="keyword">new</span> BufferedOutputStream(outputStream);</div><div class="line">        in = <span class="keyword">new</span> BufferedInputStream(conn.getInputStream());</div><div class="line">        <span class="keyword">int</span> b;</div><div class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</div><div class="line">            out.write(b);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</div><div class="line">            conn.disconnect();</div><div class="line">        &#125;</div><div class="line">        CloseUtils.closeIO(in, out);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，下次再获取该文件就不要走网络请求了。 DiskLruCache 缓存的查找和添加过程类似，首先 通过 get(key) 方法获取一个 Snapshot 对象，通过它获取到文件的输入流，有了 输入流，如果是一个图片，就可以通过 BitmapFactory.decodeStream() 来获取到 bitmap 对象了。但为了避免 oom，需要对图片进行压缩处理，这里有一个问题，FileInputStream 是一种有序的文件流，如果 decodeStream 两次，会影响文件流的位置属性，导致第二次 decodeStream 时，返回的是 null。解决办法是通过文件流得到对应的文件描述，然后通过 BitmapFactory.decodeFileDescriptor 来加载一张缩略图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">get</span><span class="params">(String url,<span class="keyword">int</span> reqWidth,<span class="keyword">int</span> reqHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</div><div class="line">    DiskLruCache.Snapshot snapshot = mDiskLrucache.get(key);</div><div class="line">    <span class="keyword">if</span>(snapshot!=<span class="keyword">null</span>)&#123;</div><div class="line">        FileInputStream fis = (FileInputStream) snapshot.getInputStream(<span class="number">0</span>);</div><div class="line">        FileDescriptor fileDescriptor = fis.getFD();</div><div class="line">        bitmap = ImageResizer.decodeSampledBitmapFromDescriptor(fileDescriptor, reqWidth, reqHeight);</div><div class="line">        <span class="comment">//add to memory</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bitmap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，应该对 DiskLruCache 如何使用有了一个了解。</p>
<h2 id="非常棒的文章"><a href="#非常棒的文章" class="headerlink" title="非常棒的文章"></a>非常棒的文章</h2><p><a href="http://zhangshixi.iteye.com/blog/673789" target="_blank" rel="external">LinkedHashMap的实现原理</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="external">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></p>
<p><br><br><br></p>
<p><a rel="external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/cn/88x31.png"></a><br>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议</a>进行许可。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/" class="pre">View 的 事件分发体系 及 滑动冲突解决方案</a><a href="/2016/12/13/Java-Reference/" class="next">谈谈 Java 的引用类型</a></div><div data-thread-key="2016/12/14/LruCach-and-DiskLruCachee/" data-title="Android 中 Lru 缓存算法分析" data-url="https://mjd507.github.io/2016/12/14/LruCach-and-DiskLruCachee/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/12/14/LruCach-and-DiskLruCachee/" data-title="Android 中 Lru 缓存算法分析" data-url="https://mjd507.github.io/2016/12/14/LruCach-and-DiskLruCachee/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-in-lianhuaguoji/">莲花国际的日子</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/">View 的 事件分发体系 及 滑动冲突解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/LruCach-and-DiskLruCachee/">Android 中 Lru 缓存算法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/13/Java-Reference/">谈谈 Java 的引用类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/ADB-Commands/">ADB 常见命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/Handler-looper-message/">谈谈 Handler 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/06/AsyncTask-Source-Code/">AsyncTask 源码解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/04/Android-memory-leak/">Android 内存泄漏 的解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/Mac-Skills/">Mac OS 上的一些疑问的解决方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/Android-thread-pool/">说说线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Bad-Weekends/">当小偷遇上共享经济</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Cleaner.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'mjd507'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>