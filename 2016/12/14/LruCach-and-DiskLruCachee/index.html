<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 中 Lru 缓存算法分析 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 中 Lru 缓存算法分析</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 中 Lru 缓存算法分析</h1><div class="post-meta">2016-12-14<span> | </span><span class="category"><a href="/categories/Java-Android/">Java &amp; Android</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">1.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LruCache"><span class="toc-number">2.</span> <span class="toc-text">LruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DiskLruCache"><span class="toc-number">3.</span> <span class="toc-text">DiskLruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E6%A3%92%E7%9A%84%E6%96%87%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">非常棒的文章</span></a></li></ol></div></div><div class="post-content"><p>Android 项目设计到大量 图片，文件时，都会使用到缓存技术，一般项目框架都会帮助我们封装好，我们只需要指定具体的缓存策略就可以了；缓存的策略或者说算法有很多种，比如 FIFO，FILO，LRU 等，本文主要分析一下 LruCache 以及 DiskLruCache。LruCache 在 Android 3.1 之后就出现在 Android 源码中了，DiskLruCache 得到官方推荐，但还未出现在源码里。<a target="_blank" rel="noopener" href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">查看 DiskLruCache.java 源码</a>，另外，JakeWharton 也有一份 <a target="_blank" rel="noopener" href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>，可以看看。</p>
<span id="more"></span>

<p>再看 LruCache 源码之前，有必要先了解一下这个类：LinkedHashMap。LruCache 内部就是使用这个 map 来维护缓存数据的。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>先看一个小栗子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;021&quot;</span>, <span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;0512&quot;</span>, <span class="string">&quot;suzhou&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;010&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;021&quot;</span>, <span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;0512&quot;</span>, <span class="string">&quot;suzhou&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;010&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(linkedHashMap);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0512</span>=suzhou, <span class="number">021</span>=shanghai, <span class="number">010</span>=beijing&#125;</span><br><span class="line">&#123;<span class="number">021</span>=shanghai, <span class="number">0512</span>=suzhou, <span class="number">010</span>=beijing&#125;</span><br></pre></td></tr></table></figure>
<p>通过结果也可以猜到，LinkedHashMap 对内部存储的关系映射数据是有序的。我们看下它的源码，先看它内部的静态类 LinkedEntry ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedEntry adds nxt/prv double-links to plain HashMapEntry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; nxt;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; prv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create the header entry */</span></span><br><span class="line">    LinkedEntry() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        nxt = prv = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a normal entry */</span></span><br><span class="line">    LinkedEntry(K key, V value, <span class="keyword">int</span> hash, HashMapEntry&lt;K, V&gt; next,</span><br><span class="line">                LinkedEntry&lt;K, V&gt; nxt, LinkedEntry&lt;K, V&gt; prv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, value, hash, next);</span><br><span class="line">        <span class="keyword">this</span>.nxt = nxt;</span><br><span class="line">        <span class="keyword">this</span>.prv = prv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，LinkedEntry 继承了 HashMapEntry，该 Entry 除了保存当前对象的引用外，还同时增加了两个 Entry，prv、nxt 来保存对前一个 和 后一个元素的引用。我们先看它存储数据的方法 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNewEntry</span><span class="params">(K key, V value, <span class="keyword">int</span> hash, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed to do so.</span></span><br><span class="line">    LinkedEntry&lt;K, V&gt; eldest = header.nxt;</span><br><span class="line">    <span class="keyword">if</span> (eldest != header &amp;&amp; removeEldestEntry(eldest)) &#123;</span><br><span class="line">        remove(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new entry, link it on to list, and put it into table</span></span><br><span class="line">    LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; newTail = <span class="keyword">new</span> LinkedEntry&lt;K,V&gt;(</span><br><span class="line">            key, value, hash, table[index], header, oldTail);</span><br><span class="line">    table[index] = oldTail.nxt = header.prv = newTail;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap 里没有重写 put 方法，而是重写了 HashMap 的 put 方法调用的子方法 addNewEntry，提供了自己特有的双向链接列表的实现。再看下读取数据的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This method is overridden to eliminate the need for a polymorphic</span></span><br><span class="line"><span class="comment">     * invocation in superclass at the expense of code duplication.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashMapEntry&lt;K, V&gt; e = entryForNullKey;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace with Collections.secondaryHash when the VM is fast enough (http://b/8290590).</span></span><br><span class="line">    <span class="keyword">int</span> hash = secondaryHash(key);</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">            e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        K eKey = e.key;</span><br><span class="line">        <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accessOrder)</span><br><span class="line">                makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面有一个 accessOrder，它是一个 布尔值，true 代表按访问顺序排，false 代表按插入顺序排，默认为 false，在构造函数里可以看到。如果打算按访问顺序（最先访问的在最前面）来保存元素，那么可以用它另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> LinkedEntry&lt;K, V&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>accessOrder 就为实现 Lru 算法的实现铺好了路。Lru 算法 ： 最少最近使用的对象，正好是基于访问顺序，利用 accessOrder 这一属性就非常简单了，下面就来看看 Lru 算法的实现。</p>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>先看构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用 LruCache 需提供一个缓存的最大的 size，当超过这个 size 就回收；另外，构造了一个 LinkedHashMap，accessOrder 传的值为 true，果然是按访问顺序排序。<br>LruCache 存储和读取的方法都是调用 LinkedHashMap 的方法，这里就不贴了。我们一般使用如下方法来构建一个 LruCache：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cacheSize = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 4MiB</span></span><br><span class="line">LruCache&lt;String, Bitmap&gt; bitmapCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getByteCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>创建 DiskLruCache：DiskLruCache 构造方法被私有化了，并提供了 open 方法来创建自身。该方法有四个参数，第一个是存储目录，可以选择 SD 卡上的缓存目录，如果想要应用卸载后，此目录数据一并删除，可以这样指定 &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;package_name&#x2F;cache. 第二个参数是应用版本号，一般设为 1，当版本号发生改变时，会清除之前的缓存文件，但实际开发中作用不大，很多情况即使版本号改变了，之前的缓存还在，所以一般设为 1，第三个参数表示单个节点对应的数据的个数，一般也设为 1，第四个参数表示表示缓存的总大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;valueCount &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// prefer to pick up where we left off</span></span><br><span class="line">        DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">        <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.readJournal();</span><br><span class="line">                cache.processJournal();</span><br><span class="line">                cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),</span><br><span class="line">                        IO_BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">return</span> cache;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line"><span class="comment">//                System.logW(&quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot;</span></span><br><span class="line"><span class="comment">//                        + journalIsCorrupt.getMessage() + &quot;, removing&quot;);</span></span><br><span class="line">                cache.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// create a new empty cache</span></span><br><span class="line">        directory.mkdirs();</span><br><span class="line">        cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">        cache.rebuildJournal();</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>DiskLruCache 在缓存对象的时候，如果 key 是一个 url，最好先用 key 的 md5 值作为新的 key 去缓存，主要是为了避免 url 中的特殊字符的影响。有了 key 之后，通过 edit(key) 方法获取一个 Editor 对象，在通过 这个 Editor 获得输出流，我们从网络下载文件时直接将获得的输入流写到这个 输出流当中，在通过 editor.commit() 方法将流写入文件系统，看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</span><br><span class="line">    DiskLruCache.Editor editor = mDiskLrucache.edit(key);</span><br><span class="line">    <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (downloadUrlToStream(url, outputStream)) &#123;</span><br><span class="line">            editor.commit();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            editor.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        mDiskLrucache.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadUrlToStream</span><span class="params">(String url, OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">    URL urlStr = <span class="keyword">null</span>;</span><br><span class="line">    HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        urlStr = <span class="keyword">new</span> URL(url);</span><br><span class="line">        conn = (HttpURLConnection) urlStr.openConnection();</span><br><span class="line">        out = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(conn.getInputStream());</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        CloseUtils.closeIO(in, out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，下次再获取该文件就不要走网络请求了。 DiskLruCache 缓存的查找和添加过程类似，首先 通过 get(key) 方法获取一个 Snapshot 对象，通过它获取到文件的输入流，有了 输入流，如果是一个图片，就可以通过 BitmapFactory.decodeStream() 来获取到 bitmap 对象了。但为了避免 oom，需要对图片进行压缩处理，这里有一个问题，FileInputStream 是一种有序的文件流，如果 decodeStream 两次，会影响文件流的位置属性，导致第二次 decodeStream 时，返回的是 null。解决办法是通过文件流得到对应的文件描述，然后通过 BitmapFactory.decodeFileDescriptor 来加载一张缩略图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">get</span><span class="params">(String url,<span class="keyword">int</span> reqWidth,<span class="keyword">int</span> reqHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</span><br><span class="line">    DiskLruCache.Snapshot snapshot = mDiskLrucache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(snapshot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        FileInputStream fis = (FileInputStream) snapshot.getInputStream(<span class="number">0</span>);</span><br><span class="line">        FileDescriptor fileDescriptor = fis.getFD();</span><br><span class="line">        bitmap = ImageResizer.decodeSampledBitmapFromDescriptor(fileDescriptor, reqWidth, reqHeight);</span><br><span class="line">        <span class="comment">//add to memory</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里，应该对 DiskLruCache 如何使用有了一个了解。</p>
<h2 id="非常棒的文章"><a href="#非常棒的文章" class="headerlink" title="非常棒的文章"></a>非常棒的文章</h2><p><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/673789">LinkedHashMap的实现原理</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/28863651">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>Android 中 Lru 缓存算法分析</p><p><span>Author: </span>mjd507</p><p><span>Date: </span>2016-12-14</p><p><span>Last Update: </span>2024-01-27</p><p><span>Blog Link: </span><a href="/2016/12/14/LruCach-and-DiskLruCachee/">https://mjd507.github.io/2016/12/14/LruCach-and-DiskLruCachee/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2016/12/14/LruCach-and-DiskLruCachee/"></i></span></p><p><span>Copyright Declaration: </span>This station is mainly used to sort out incomprehensible knowledge. I have not fully mastered most of the content. Please refer carefully.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/">View 的 事件分发体系 及 滑动冲突解决方案</a><a class="next" href="/2016/12/13/Java-Reference/">谈谈 Java 的引用类型</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Back-End/">Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-Algorithm/">Data Structure & Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Devops/">Devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Android/">Java & Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operation-System/">Operation System</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://daimajia.com/" title="代码家" target="_blank">代码家</a><ul></ul><a href="https://sivers.org/" title="Derek Sivers" target="_blank">Derek Sivers</a><ul></ul><a href="http://www.hugogu.cn/" title="Hugo Gu" target="_blank">Hugo Gu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>