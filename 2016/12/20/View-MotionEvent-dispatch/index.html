<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>View 的 事件分发体系 | Cleaner</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">View 的 事件分发体系</h1><a id="logo" href="/.">Cleaner</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">View 的 事件分发体系</h1><div class="post-meta">Dec 20, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/12/20/View-MotionEvent-dispatch/" href="/2016/12/20/View-MotionEvent-dispatch/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity-对事件的分发"><span class="toc-number">1.</span> <span class="toc-text">Activity 对事件的分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewGroup-对事件的分发"><span class="toc-number">2.</span> <span class="toc-text">ViewGroup 对事件的分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View-对-事件的处理过程"><span class="toc-number">3.</span> <span class="toc-text">View 对 事件的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非常棒的文章"><span class="toc-number">5.</span> <span class="toc-text">非常棒的文章</span></a></li></ol></div></div><div class="post-content"><p>Android 中 当遇到滑动冲突的问题，就会涉及到事件的分发与响应。事件分发，事件拦截，事件处理 是 理清各个 view 所要处理的事件的三个重要的方法。这里就结合源码分析一下 从点击 Activity 上的一个控件开始，到事件响应结束的 事件传递的整个流程。包括 Activity 对事件的处理，ViewGroup 对事件的处理，View 对事件的处理。</p>
<a id="more"></a>
<p>先来看一张 事件分发 的流程图（搜刮自网络）<br><img src="/images/Touch-Event-Dispatch.png" alt="Touch 事件传递流程图"></p>
<p>图里表现的非常清楚，当 view 产生一个 touch 事件后，如果 该 view 是一个 ViewGroup, 则去判断 ViewGroup 里面的 onInterceptTouchEvent() 方法，表示是否拦截事件，默认是返回 false，表示不拦截，让事件传递给 子view，子view 如果还是 ViewGroup，默认仍然继续向下传递，直到 子 view 不是 ViewGroup，则直接调用 子view 的 onTouchEvent() 方法，return true 表示消费了此事件，传递过程结束，false 则将事件向上(ViewGroup)传，都不处理的话，最终会传递到 Activity，此时，Activity 的 onTouchEvent() 将被调用。</p>
<p>如果我们中途重写了 ViewGroup 的 onInterceptTouchEvent() 方法，让其返回 true，则表示 我们这个 ViewGroup 拦截了这个事件，在 onTouchEvent() 方法中可以处理，不处理则与上面向上传递的流程一样。</p>
<p>当然，图中只是比较普遍的一种事件传递流程，实际上具体的细节与图还不尽相同，比如 ViewGroup 的 onInterceptTouchEvent() 方法并不是一定会执行的，具体的本篇文章会详细分析。</p>
<h2 id="Activity-对事件的分发"><a href="#Activity-对事件的分发" class="headerlink" title="Activity 对事件的分发"></a>Activity 对事件的分发</h2><p>点击事件产生时，最先传递给当前的 Activity，由 Activity 的 dispatchTouchEvent() 来进行事件派发，来看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>onUserInteraction() 是 Activity 通过 Window 向 view <strong>分发事件之前</strong> 调用的方法，我们一般可以重写该方法来管理状态栏的通知。<br>重点在 getWindow().superDispatchTouchEvent(ev) 这个方法，这里就是开始调用 Window 的 事件分发的方法，(如果此方法消费了事件，那么 Activity 也就消费事件，不再传递，循环结束)，我们跟进去看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Window 类的 superDispatchTouchEvent 是一个抽象方法，在它源码的文档中，可以看到一段注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Abstract base class for a top-level window look and behavior policy.  An</div><div class="line"> * instance of this class should be used as the top-level view added to the</div><div class="line"> * window manager. It provides standard UI policies such as a background, title</div><div class="line"> * area, default key processing, etc.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;The only existing implementation of this abstract class is</div><div class="line"> * android.policy.PhoneWindow, which you should instantiate when needing a</div><div class="line"> * Window.  Eventually that class will be refactored and a factory method</div><div class="line"> * added for creating Window instances without knowing about a particular</div><div class="line"> * implementation.</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>Window 类可以控制顶级 view 的外观和行为策略，它的唯一实现类是 android.policy.PhoneWindow. 这个类是在 FrameWork 层里面，具体路径为：<br><strong>frameworks/policies/base/phone/com/android/internal/policy/impl/PhoneWindow.java </strong>，<a href="https://android.googlesource.com/platform/frameworks/policies/base/+/donut-release/phone/com/android/internal/policy/impl/PhoneWindow.java" target="_blank" rel="external">在线查看</a><br>来看一下它是如何分发事件的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line">        installDecor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mDecor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line">        mDecor = generateDecor();</div><div class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">        mContentParent = generateLayout(mDecor);</div><div class="line">        mTitleView = (TextView)findViewById(com.android.internal.R.id.title);</div><div class="line">        <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</div><div class="line">                View titleContainer = findViewById(com.android.internal.R.id.title_container);</div><div class="line">                <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</div><div class="line">                    titleContainer.setVisibility(View.GONE);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mTitleView.setVisibility(View.GONE);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (mContentParent <span class="keyword">instanceof</span> FrameLayout) &#123;</div><div class="line">                    ((FrameLayout)mContentParent).setForeground(<span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mTitleView.setText(mTitle);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有一个 mDecor，它是一个 DecorView，是 PhoneWindow 的一个内部类，我们在 Activity 里面 使用 getWindow().getDecorView() 获取到的 view 就是这个 DecorView，可以看到，Window 在获取到这个 decorView 时，把 TitleView 单拎出来出来封装好了，我们使用的 setContentView(View v)，就是把自己的布局 塞到 这个 decorView 当中。<br>好，现在事件传递到了 DecorView 当中，DecorView 继承自 FrameLayout，事件 FrameLayout 继承自 ViewGroup，最终调用的是 ViewGroup 的事件分发的方法。下面就分析 ViewGroup 的事件分发方法。</p>
<h2 id="ViewGroup-对事件的分发"><a href="#ViewGroup-对事件的分发" class="headerlink" title="ViewGroup 对事件的分发"></a>ViewGroup 对事件的分发</h2><p>ViewGroup 的 onInterceptTouchEvent() 永远返回 false，意味着对事件永远不拦截，这也是很好理解的，不然 子view 就不会响应事件了 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ViewGroup 的 dispatchTouchEvent() 方法很长，我们一点一点分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">    cancelAndClearTouchTargets(ev);</div><div class="line">    resetTouchState();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里进行了初始化 down 事件，在 ACTION_DOWN 事件到来时，会清除以往的 Touch 状态，cancelAndClearTouchTargets() 方法里将 mFirstTouchTarget 设置为 null，resetTouchState() 方法里重置了 touch 状态标识。接着往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">        intercepted = onInterceptTouchEvent(ev);</div><div class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        intercepted = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">    <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">    intercepted = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>intercepted 这个变量判断是否拦截，当事件是 ACTION_DOWN 或者 mFirstTouchTarget != null 时，ViewGroup 正常情况下是不拦截的，（ mFirstTouchTarget != null 从后面的逻辑可以知道，它是表示 ViewGroup 没有拦截 Touch 事件并且 将事件交给了 子View 消费了 ）。 </p>
<p>但是这里有一个情况，就是 FLAG_DISALLOW_INTERCEPT 这个标记位，如果 ViewGroup 的子类 调用 getParent().requestDisallowInterceptTouchEvent(boolean disallowIntercept)， 那么就可以改变这个标记位的值，具体有两种情况：<br>如果参数 disallowIntercept 值为 true，表示禁止 ViewGroup 拦截，那么 intercepted = false;<br>如果参数 disallowIntercept 值为 false，那么 intercepted = onInterceptTouchEvent(ev)，就可以根据 onInterceptTouchEvent() 的返回值来设置是否 禁止 ViewGroup 对事件的拦截，默认是 false，我们可以修改这个值来拦截事件。</p>
<p>有一点注意：getParent().requestDisallowInterceptTouchEvent() 方法不会影响 ViewGroup 对 ACTION_DOWN 事件的处理，只能拦截 ACTION_MOVE 和 ACTION_UP 事件，前面已经提过，ViewGroup 事件分发一开始就在 ACTION_DOWN 时重置了 Touch 状态标识，即 FLAG_DISALLOW_INTERCEPT。</p>
<p>如果事件不是 ACTION_DOWN 并且 mFirstTouchTarget == null，那么直接将 intercepted == true，表示 ViewGroup 拦截 Touch 事件，直白地说：如果 ACTION_DOWN 没有被 子View 消费， 那么当 ACTION_MOVE 和 ACTION_UP 到来时 ViewGroup 不再去调用 onInterceptTouchEvent() 判断是否需要拦截而是直接的将 intercepted == true 表示由其自身处理 Touch 事件。</p>
<p>这部分 FLAG_DISALLOW_INTERCEPT 这个标识位可以对一些 滑动冲突 的问题 提供了一个解决思路。</p>
<p>接着看 ViewGroup 不拦截事件的时候，分发事件给 子view 的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> View[] children = mChildren;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ?</div><div class="line">            getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">    <span class="keyword">final</span> View child = children[childIndex];</div><div class="line">    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newTouchTarget = getTouchTarget(child);</div><div class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetCancelNextUpFlag(child);</div><div class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">        <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">        mLastTouchDownTime = ev.getDownTime();</div><div class="line">        mLastTouchDownIndex = childIndex;</div><div class="line">        mLastTouchDownX = ev.getX();</div><div class="line">        mLastTouchDownY = ev.getY();</div><div class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里首先遍历 ViewGroup 的所有 子view，判断 子view 是否能够接受到点击事件（主要看两点：1. 子view 是否在播放动画 2.点击事件的坐标是否在 子view 的区域内），如果满足其中一个，那么事件就会传递给这个 子view 来处理，上面的 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign) 方法<br>实际上就是调用的 子view 的 dispatchTouchEvent() 方法，可以看下该方法内部的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    handled = child.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为上面 child 传递的不是 null，所以会直接调用 子view 的 dispatchTouchEvent() 方法，这样事件就交给 子view 处理了，从而完成了一轮事件分发。</p>
<p>如果 子view 的 dispatchTouchEvent() 返回 false，ViewGroup 就会继续遍历，将事件发给下一个 子 view。<br>如果 子view 的 dispatchTouchEvent() 返回 true，这里就会跳出循环，终止遍历，跳出之前，还做了一些事情，来看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，将 mFirstTouchTarget 进行了赋值，它是一种单链表结构，随后 alreadyDispatchedToNewTouchTarget 置为 true，表示已经将 Touch 事件分发到了 子View，并且 子View 消费掉了 Touch 事件，前面已经有分析，mFirstTouchTarget 是否为空，直接影响到 ViewGroup 对事件拦截的策略。</p>
<p>好，如果遍历所有的 子view 后 mFirstTouchTarget 仍然为 null，这里就包含两种情况：第一种 ViewGroup 没有 子View；第二种是 子View 虽然处理了点击事件，但是在 dispatchTouchEvent() 方法中 返回了 false (一般是因为 子View 在 onTouchEvent 里面返回来 false)。这两种情况，看 ViewGroup 是如何处理的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">            TouchTarget.ALL_POINTER_IDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里 第三个参数 child 传的是 null，所以会调用 super.dispatchTouchEvent(event) 方法，这里就转到了 View 的 dispatchTouchEvent() 方法中去了，下面接着看 View 的事件传递过程。</p>
<h2 id="View-对-事件的处理过程"><a href="#View-对-事件的处理过程" class="headerlink" title="View 对 事件的处理过程"></a>View 对 事件的处理过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (onTouchEvent(event)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View 的 dispatchTouchEvent() 方法比较简单，它不能 向下继续分发事件， 也没有拦截事件的方法，所以只能自己处理事件。这里 首先判断 有没有设置 mOnTouchListener，如果有，在判断 mOnTouchListener.onTouch() 方法有没有返回 true，如果我们在外面设置了 onTouch() 方法 返回了 true，那么 事件就此消费，不会再执行 onTouchEvent() 方法。如果没有，我们接着看 onTouchEvent() 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">    <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">        setPressed(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">    <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里判断了 View 处于不可用状态下的处理过程，不可用状态下，仍然可以消耗点击事件，只要 View 是 clickable 或者 longClickable 的。<br>在看这一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                    <span class="comment">//...</span></div><div class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                        removeLongPressCallback();</div><div class="line"></div><div class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                            <span class="comment">// of the view update before click actions start.</span></div><div class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                performClick();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//...</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>View 是 clickable 或者 longClickable 的状态下，会触发 performClick() 方法，该方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line"></div><div class="line">    ListenerInfo li = mListenerInfo;</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">        playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里如果 mOnClickListener 不为 null，会调用它的 onClick 方法。View 的 LONG_CLICKABLE 属性默认为 false，CLICKABLE 属性和 View 有关，可点击的 View 比如 Button，其 CLICKABLE 属性为 true，不可点击的 View 比如 TextView，其属性为 false。通过 setOnClickListener 会自动将 View 的 CLICKABLE 设为 true，setOnLongClickListerner 会自动将 View 的 LONG_CLICKABLE 设为 true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">        setClickable(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnLongClickListener</span><span class="params">(OnLongClickListener l)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isLongClickable()) &#123;</div><div class="line">        setLongClickable(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    getListenerInfo().mOnLongClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，事件分发的源码重要的部分都已经分析完了，下面在总结一些规律性的东西帮助记忆。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一个点击事件产生后，它的传递过程如下： Activity -&gt; Window -&gt; View。顶级 View 接收到事件之后，就会按相应规则去分发事件。如果一个 View 的 onTouchEvent 方法返回 false，那么将会交给父容器的 onTouchEvent 方法进行处理，逐级往上，如果所有的 View 都不处理该事件，则交由 Activity 的 onTouchEvent 进行处理。</li>
<li>ViewGroup 默认不拦截任何事件。</li>
<li>子View 可以通过调用 getParent().requestDisallowInterceptTouchEvent(true); 阻止 ViewGroup 对其 MOVE 或者 UP 事件进行拦截</li>
<li>如果某一个 View 开始处理事件，如果他不消耗 ACTION_DOWN 事件（也就是 onTouchEvent 返回 false），则同一事件序列比如接下来进行 ACTION_MOVE，ACTION_UP 都不会再交给该 View 处理，而是将事件交由它的父容器 onTouchEvent 方法 去处理。</li>
<li>如果某一个 View 开始处理事件，如果他不消耗 除 ACTION_DOWN 以外的事件，那么这个事件会消失，此时 父容器的 onTouchEvent 并不会调用，并且当前 view 可以持续收到后续的事件，最终这些消失的事件会传递给 Activity 处理。</li>
<li>TextView、ImageView 这些不作为容器的 View，一旦接受到事件，就调用 onTouchEvent 方法，它们本身没有 onInterceptTouchEvent 方法。正常情况下，它们都会消耗事件（返回 true），除非它们是不可点击的（clickable 和 longClickable 都为 false）。　</li>
<li>View 的 enable 属性不影响 onTouchEvent 的返回值。哪怕一个 view 是 disable 的，只要 clickable 和 longClickable 有一个为 true，onTouchEvent 就返回 true。</li>
<li>点击事件分发过程如下 dispatchTouchEvent —&gt; OnTouchListener 的 onTouch 方法 —&gt; onTouchEvent -&gt; OnClickListener 的 onClick 方法。也就是说，我们平时调用的 setOnClickListener，优先级是最低的，所以，onTouchEvent 或 OnTouchListener 的 onTouch 方法如果返回 true，则不响应 onClick 方法。</li>
</ul>
<h2 id="非常棒的文章"><a href="#非常棒的文章" class="headerlink" title="非常棒的文章"></a>非常棒的文章</h2><p><a href="http://blog.csdn.net/guolin_blog/article/details/9097463/" target="_blank" rel="external">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a><br><a href="https://github.com/HotBitmapGG/AndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">事件分发机制源码分析</a></p>
<p><br><br><br></p>
<p><a rel="external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/cn/88x31.png"></a><br>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议</a>进行许可。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/12/14/LruCach-and-DiskLruCachee/" class="next">Android 中 Lru 缓存算法分析</a></div><div data-thread-key="2016/12/20/View-MotionEvent-dispatch/" data-title="View 的 事件分发体系" data-url="https://mjd507.github.io/2016/12/20/View-MotionEvent-dispatch/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/12/20/View-MotionEvent-dispatch/" data-title="View 的 事件分发体系" data-url="https://mjd507.github.io/2016/12/20/View-MotionEvent-dispatch/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-in-lianhuaguoji/">莲花国际的日子</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/View-MotionEvent-dispatch/">View 的 事件分发体系</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/LruCach-and-DiskLruCachee/">Android 中 Lru 缓存算法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/13/Java-Reference/">谈谈 Java 的引用类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/ADB-Commands/">ADB 常见命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/Handler-looper-message/">谈谈 Handler 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/06/AsyncTask-Source-Code/">AsyncTask 源码解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/04/Android-memory-leak/">Android 内存泄漏 的解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/Mac-Skills/">Mac OS 上的一些疑问的解决方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/Android-thread-pool/">说说线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Bad-Weekends/">当小偷遇上共享经济</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Cleaner.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'mjd507'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>