<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>View 的 事件分发体系 及 滑动冲突解决方案 | mjd507</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '1c847d4fb515d19b6108f15a5387f1d6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">View 的 事件分发体系 及 滑动冲突解决方案</h1><a id="logo" href="/.">mjd507</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">View 的 事件分发体系 及 滑动冲突解决方案</h1><div class="post-meta">2016-12-20<span> | </span><span class="category"><a href="/categories/Java-Android/">Java &amp; Android</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%BD%93%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">View 的事件分发体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">1.1.</span> <span class="toc-text">Activity 对事件的分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewGroup-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">1.2.</span> <span class="toc-text">ViewGroup 对事件的分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E5%AF%B9-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">View 对 事件的处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View-%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81"><span class="toc-number">2.</span> <span class="toc-text">View 的滑动冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA"><span class="toc-number">2.1.</span> <span class="toc-text">外部拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA"><span class="toc-number">2.2.</span> <span class="toc-text">内部拦截</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E6%A3%92%E7%9A%84%E6%96%87%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">非常棒的文章</span></a></li></ol></div></div><div class="post-content"><p>Android 中 当遇到滑动冲突的问题，就会涉及到事件的分发与响应。事件分发，事件拦截，事件处理 是 理清各个 view 所要处理的事件的三个重要的方法。这里就结合源码分析一下 从点击 Activity 上的一个控件开始，到事件响应结束的 事件传递的整个流程。包括 Activity 对事件的处理，ViewGroup 对事件的处理，View 对事件的处理。</p>
<span id="more"></span>

<p><strong>声明：本文参考自 《Android开发艺术探索》，非常赞的<a target="_blank" rel="noopener" href="https://www.amazon.cn/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E4%BB%BB%E7%8E%89%E5%88%9A/dp/B014HV1X3K/ref=sr_1_1?s=books&ie=UTF8&qid=1482818361&sr=1-1&keywords=android+%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2">一本书</a>，有兴趣可以去看一看。</strong></p>
<h2 id="View-的事件分发体系"><a href="#View-的事件分发体系" class="headerlink" title="View 的事件分发体系"></a>View 的事件分发体系</h2><p>先来看一张 事件分发 的流程图（搜刮自网络）<br><img src="https://user-images.githubusercontent.com/8939151/111025296-23d55180-841e-11eb-9f5e-4fde21d59080.png" alt="Touch 事件传递流程图"></p>
<p>图里表现的非常清楚，当 view 产生一个 touch 事件后，如果 该 view 是一个 ViewGroup, 则去判断 ViewGroup 里面的 onInterceptTouchEvent() 方法，表示是否拦截事件，默认是返回 false，表示不拦截，让事件传递给 子view，子view 如果还是 ViewGroup，默认仍然继续向下传递，直到 子 view 不是 ViewGroup，则直接调用 子view 的 onTouchEvent() 方法，return true 表示消费了此事件，传递过程结束，false 则将事件向上(ViewGroup)传，都不处理的话，最终会传递到 Activity，此时，Activity 的 onTouchEvent() 将被调用。</p>
<p>如果我们中途重写了 ViewGroup 的 onInterceptTouchEvent() 方法，让其返回 true，则表示 我们这个 ViewGroup 拦截了这个事件，在 onTouchEvent() 方法中可以处理，不处理则与上面向上传递的流程一样。</p>
<p>当然，图中只是比较普遍的一种事件传递流程，实际上具体的细节与图还不尽相同，比如 ViewGroup 的 onInterceptTouchEvent() 方法并不是一定会执行的，具体的本篇文章会详细分析。</p>
<h3 id="Activity-对事件的分发"><a href="#Activity-对事件的分发" class="headerlink" title="Activity 对事件的分发"></a>Activity 对事件的分发</h3><p>点击事件产生时，最先传递给当前的 Activity，由 Activity 的 dispatchTouchEvent() 来进行事件派发，来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onUserInteraction() 是 Activity 通过 Window 向 view <strong>分发事件之前</strong> 调用的方法，我们一般可以重写该方法来管理状态栏的通知。<br>重点在 getWindow().superDispatchTouchEvent(ev) 这个方法，这里就是开始调用 Window 的 事件分发的方法，(如果此方法消费了事件，那么 Activity 也就消费事件，不再传递，循环结束)，我们跟进去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Window 类的 superDispatchTouchEvent 是一个抽象方法，在它源码的文档中，可以看到一段注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for a top-level window look and behavior policy.  An</span></span><br><span class="line"><span class="comment"> * instance of this class should be used as the top-level view added to the</span></span><br><span class="line"><span class="comment"> * window manager. It provides standard UI policies such as a background, title</span></span><br><span class="line"><span class="comment"> * area, default key processing, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The only existing implementation of this abstract class is</span></span><br><span class="line"><span class="comment"> * android.policy.PhoneWindow, which you should instantiate when needing a</span></span><br><span class="line"><span class="comment"> * Window.  Eventually that class will be refactored and a factory method</span></span><br><span class="line"><span class="comment"> * added for creating Window instances without knowing about a particular</span></span><br><span class="line"><span class="comment"> * implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Window 类可以控制顶级 view 的外观和行为策略，它的唯一实现类是 android.policy.PhoneWindow. 这个类是在 FrameWork 层里面，具体路径为：<br>**frameworks/policies/base/phone/com/android/internal/policy/impl/PhoneWindow.java **，<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/policies/base/+/donut-release/phone/com/android/internal/policy/impl/PhoneWindow.java">在线查看</a><br>来看一下它是如何分发事件的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        mTitleView = (TextView)findViewById(com.android.internal.R.id.title);</span><br><span class="line">        <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                View titleContainer = findViewById(com.android.internal.R.id.title_container);</span><br><span class="line">                <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    titleContainer.setVisibility(View.GONE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTitleView.setVisibility(View.GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mContentParent <span class="keyword">instanceof</span> FrameLayout) &#123;</span><br><span class="line">                    ((FrameLayout)mContentParent).setForeground(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mTitleView.setText(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有一个 mDecor，它是一个 DecorView，是 PhoneWindow 的一个内部类，我们在 Activity 里面 使用 getWindow().getDecorView() 获取到的 view 就是这个 DecorView，可以看到，Window 在获取到这个 decorView 时，把 TitleView 单拎出来出来封装好了，我们使用的 setContentView(View v)，就是把自己的布局 塞到 这个 decorView 当中。<br>好，现在事件传递到了 DecorView 当中，DecorView 继承自 FrameLayout，事件 FrameLayout 继承自 ViewGroup，最终调用的是 ViewGroup 的事件分发的方法。下面就分析 ViewGroup 的事件分发方法。</p>
<h3 id="ViewGroup-对事件的分发"><a href="#ViewGroup-对事件的分发" class="headerlink" title="ViewGroup 对事件的分发"></a>ViewGroup 对事件的分发</h3><p>ViewGroup 的 onInterceptTouchEvent() 永远返回 false，意味着对事件永远不拦截，这也是很好理解的，不然 子view 就不会响应事件了 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup 的 dispatchTouchEvent() 方法很长，我们一点一点分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里进行了初始化 down 事件，在 ACTION_DOWN 事件到来时，会清除以往的 Touch 状态，cancelAndClearTouchTargets() 方法里将 mFirstTouchTarget 设置为 null，resetTouchState() 方法里重置了 touch 状态标识。接着往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>intercepted 这个变量判断是否拦截，当事件是 ACTION_DOWN 或者 mFirstTouchTarget != null 时，ViewGroup 正常情况下是不拦截的，（ mFirstTouchTarget != null 从后面的逻辑可以知道，它是表示 ViewGroup 没有拦截 Touch 事件并且 将事件交给了 子View 消费了 ）。 </p>
<p>但是这里有一个情况，就是 FLAG_DISALLOW_INTERCEPT 这个标记位，如果 ViewGroup 的子类 调用 getParent().requestDisallowInterceptTouchEvent(boolean disallowIntercept)， 那么就可以改变这个标记位的值，具体有两种情况：<br>如果参数 disallowIntercept 值为 true，表示禁止 ViewGroup 拦截，那么 intercepted = false;<br>如果参数 disallowIntercept 值为 false，那么 intercepted = onInterceptTouchEvent(ev)，就可以根据 onInterceptTouchEvent() 的返回值来设置是否 禁止 ViewGroup 对事件的拦截，默认是 false，我们可以修改这个值来拦截事件。</p>
<p>有一点注意：getParent().requestDisallowInterceptTouchEvent() 方法不会影响 ViewGroup 对 ACTION_DOWN 事件的处理，只能拦截 ACTION_MOVE 和 ACTION_UP 事件，前面已经提过，ViewGroup 事件分发一开始就在 ACTION_DOWN 时重置了 Touch 状态标识，即 FLAG_DISALLOW_INTERCEPT。</p>
<p>如果事件不是 ACTION_DOWN 并且 mFirstTouchTarget == null，那么直接将 intercepted == true，表示 ViewGroup 拦截 Touch 事件，直白地说：如果 ACTION_DOWN 没有被 子View 消费， 那么当 ACTION_MOVE 和 ACTION_UP 到来时 ViewGroup 不再去调用 onInterceptTouchEvent() 判断是否需要拦截而是直接的将 intercepted == true 表示由其自身处理 Touch 事件。</p>
<p>这部分 FLAG_DISALLOW_INTERCEPT 这个标识位可以对一些 滑动冲突 的问题 提供了一个解决思路。</p>
<p>接着看 ViewGroup 不拦截事件的时候，分发事件给 子view 的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ?</span><br><span class="line">            getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">    <span class="keyword">final</span> View child = children[childIndex];</span><br><span class="line">    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newTouchTarget = getTouchTarget(child);</span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">        mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">        mLastTouchDownIndex = childIndex;</span><br><span class="line">        mLastTouchDownX = ev.getX();</span><br><span class="line">        mLastTouchDownY = ev.getY();</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里首先遍历 ViewGroup 的所有 子view，判断 子view 是否能够接受到点击事件（主要看两点：1. 子view 是否在播放动画 2.点击事件的坐标是否在 子view 的区域内），如果满足其中一个，那么事件就会传递给这个 子view 来处理，上面的 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign) 方法<br>实际上就是调用的 子view 的 dispatchTouchEvent() 方法，可以看下该方法内部的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上面 child 传递的不是 null，所以会直接调用 子view 的 dispatchTouchEvent() 方法，这样事件就交给 子view 处理了，从而完成了一轮事件分发。</p>
<p>如果 子view 的 dispatchTouchEvent() 返回 false，ViewGroup 就会继续遍历，将事件发给下一个 子 view。<br>如果 子view 的 dispatchTouchEvent() 返回 true，这里就会跳出循环，终止遍历，跳出之前，还做了一些事情，来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，将 mFirstTouchTarget 进行了赋值，它是一种单链表结构，随后 alreadyDispatchedToNewTouchTarget 置为 true，表示已经将 Touch 事件分发到了 子View，并且 子View 消费掉了 Touch 事件，前面已经有分析，mFirstTouchTarget 是否为空，直接影响到 ViewGroup 对事件拦截的策略。</p>
<p>好，如果遍历所有的 子view 后 mFirstTouchTarget 仍然为 null，这里就包含两种情况：第一种 ViewGroup 没有 子View；第二种是 子View 虽然处理了点击事件，但是在 dispatchTouchEvent() 方法中 返回了 false (一般是因为 子View 在 onTouchEvent 里面返回来 false)。这两种情况，看 ViewGroup 是如何处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 第三个参数 child 传的是 null，所以会调用 super.dispatchTouchEvent(event) 方法，这里就转到了 View 的 dispatchTouchEvent() 方法中去了，下面接着看 View 的事件传递过程。</p>
<h3 id="View-对-事件的处理过程"><a href="#View-对-事件的处理过程" class="headerlink" title="View 对 事件的处理过程"></a>View 对 事件的处理过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>View 的 dispatchTouchEvent() 方法比较简单，它不能 向下继续分发事件， 也没有拦截事件的方法，所以只能自己处理事件。这里 首先判断 有没有设置 mOnTouchListener，如果有，在判断 mOnTouchListener.onTouch() 方法有没有返回 true，如果我们在外面设置了 onTouch() 方法 返回了 true，那么 事件就此消费，不会再执行 onTouchEvent() 方法。如果没有，我们接着看 onTouchEvent() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">    <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里判断了 View 处于不可用状态下的处理过程，不可用状态下，仍然可以消耗点击事件，只要 View 是 clickable 或者 longClickable 的。<br>在看这一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>View 是 clickable 或者 longClickable 的状态下，会触发 performClick() 方法，该方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果 mOnClickListener 不为 null，会调用它的 onClick 方法。View 的 LONG_CLICKABLE 属性默认为 false，CLICKABLE 属性和 View 有关，可点击的 View 比如 Button，其 CLICKABLE 属性为 true，不可点击的 View 比如 TextView，其属性为 false。通过 setOnClickListener 会自动将 View 的 CLICKABLE 设为 true，setOnLongClickListerner 会自动将 View 的 LONG_CLICKABLE 设为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">        setClickable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnLongClickListener</span><span class="params">(OnLongClickListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">        setLongClickable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里，事件分发的源码重要的部分都已经分析完了，下面在总结一些规律性的东西帮助记忆。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个点击事件产生后，它的传递过程如下： Activity -&gt; Window -&gt; View。顶级 View 接收到事件之后，就会按相应规则去分发事件。如果一个 View 的 onTouchEvent 方法返回 false，那么将会交给父容器的 onTouchEvent 方法进行处理，逐级往上，如果所有的 View 都不处理该事件，则交由 Activity 的 onTouchEvent 进行处理。</li>
<li>ViewGroup 默认不拦截任何事件。</li>
<li>子View 可以通过调用 getParent().requestDisallowInterceptTouchEvent(true); 阻止 ViewGroup 对其 MOVE 或者 UP 事件进行拦截</li>
<li>如果某一个 View 开始处理事件，如果他不消耗 ACTION_DOWN 事件（也就是 onTouchEvent 返回 false），则同一事件序列比如接下来进行 ACTION_MOVE，ACTION_UP 都不会再交给该 View 处理，而是将事件交由它的父容器 onTouchEvent 方法 去处理。</li>
<li>如果某一个 View 开始处理事件，如果他不消耗 除 ACTION_DOWN 以外的事件，那么这个事件会消失，此时 父容器的 onTouchEvent 并不会调用，并且当前 view 可以持续收到后续的事件，最终这些消失的事件会传递给 Activity 处理。</li>
<li>TextView、ImageView 这些不作为容器的 View，一旦接受到事件，就调用 onTouchEvent 方法，它们本身没有 onInterceptTouchEvent 方法。正常情况下，它们都会消耗事件（返回 true），除非它们是不可点击的（clickable 和 longClickable 都为 false）。　</li>
<li>View 的 enable 属性不影响 onTouchEvent 的返回值。哪怕一个 view 是 disable 的，只要 clickable 和 longClickable 有一个为 true，onTouchEvent 就返回 true。</li>
<li>点击事件分发过程如下 dispatchTouchEvent —&gt; OnTouchListener 的 onTouch 方法 —&gt; onTouchEvent -&gt; OnClickListener 的 onClick 方法。也就是说，我们平时调用的 setOnClickListener，优先级是最低的，所以，onTouchEvent 或 OnTouchListener 的 onTouch 方法如果返回 true，则不响应 onClick 方法。</li>
</ul>
<h2 id="View-的滑动冲突"><a href="#View-的滑动冲突" class="headerlink" title="View 的滑动冲突"></a>View 的滑动冲突</h2><p>View 滑动冲突的解决有固定的套路，常见的冲突可以简单归为三种：1. 外部和内部滑动方向不一致 2. 外部和内部滑动方向一致 3. 前两种的嵌套。 基于对上面 View 的事件分发体系的理解， View 的滑动冲突就相对简单了。处理滑动冲突的思路主要有两种：外部拦截 和 内部拦截。</p>
<h3 id="外部拦截"><a href="#外部拦截" class="headerlink" title="外部拦截"></a>外部拦截</h3><p>判断滑动的特征，如果水平滑动距离 &gt; 竖直滑动距离，则为水平滑动，反之为竖直滑动。假设外部 View 可以水平滑动，内部 View 可以竖直滑动，那么在外部 View 的 onInterceptTouchEvent 方法判断，如果触摸事件为竖直滑动，则应该放行，也就是返回 false，然后交给内部 View 来处理，使内部 子View 就可以实现竖直滑动；如果触摸事件为水平滑动，外部 view 则应该拦截，交由自己处理。</p>
<p>外部拦截的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123; <span class="comment">// 外部View拦截事件  </span></span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();  </span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;  </span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;  </span><br><span class="line">        intercepted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;  </span><br><span class="line">        <span class="keyword">int</span> deltaX = x - mLastXIntercept;  </span><br><span class="line">        <span class="keyword">int</span> deltaY = y - mLastYIntercept;  </span><br><span class="line">        <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;  </span><br><span class="line">            intercepted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            intercepted = <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;  </span><br><span class="line">        intercepted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mLastXIntercept = x; <span class="comment">// 分别记录上次滑动坐标  </span></span><br><span class="line">    mLastYIntercept = y;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> intercepted; <span class="comment">// 看是否需要传递给内部View处理  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部拦截"><a href="#内部拦截" class="headerlink" title="内部拦截"></a>内部拦截</h3><p>外部 View 不拦截，交给内部 View 处理，如果内部 View 有需要就自己消耗掉，否则交给上一层，这样违反了事件分发机制，所以需配合 requestDisallowInterceptTouchEvent 方法进行处理。</p>
<p>内部拦截的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要此类点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="非常棒的文章"><a href="#非常棒的文章" class="headerlink" title="非常棒的文章"></a>非常棒的文章</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9097463/">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a><br><a target="_blank" rel="noopener" href="https://github.com/HotBitmapGG/AndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">事件分发机制源码分析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaohanluo/article/details/52130923">Android实践之ScrollView中滑动冲突处理</a><br><a target="_blank" rel="noopener" href="http://lib.csdn.net/article/android/31319">android—–滑动冲突解决案例</a><br><a target="_blank" rel="noopener" href="https://niorgai.github.io/2015/10/15/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E6%9B%B4%E5%90%88%E7%90%86%E7%9A%84%E6%8B%A6%E6%88%AA/">滑动冲突解决-更合理的拦截</a></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>View 的 事件分发体系 及 滑动冲突解决方案</p><p><span>文章作者：</span>mjd507</p><p><span>发布时间：</span>2016-12-20</p><p><span>最后更新：</span>2021-09-07</p><p><span>原始链接：</span><a href="/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/">https://mjd507.github.io/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/"></i></span></p><p><span>版权声明：</span>本站主要是用来整理不懂的知识，大部分内容我都没有完全掌握，请谨慎参考。</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/12/30/My-2016/">我的 2016</a><a class="next" href="/2016/12/14/LruCach-and-DiskLruCachee/">Android 中 Lru 缓存算法分析</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=1.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=1.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=1.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Back-End/">Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-Algorithm/">Data Structure & Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Android/">Java & Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operation-System/">Operation System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Story/">Story</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://johnnyshieh.me/" title="JohnnyShieh" target="_blank">JohnnyShieh</a><ul></ul><a href="https://daimajia.com/" title="代码家" target="_blank">代码家</a><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://sivers.org/" title="Derek Sivers" target="_blank">Derek Sivers</a><ul></ul><a href="https://www.alispit.tel/#/" title="alispittel" target="_blank">alispittel</a><ul></ul><a href="http://www.hugogu.cn/" title="Hugo Gu" target="_blank">Hugo Gu</a><ul></ul><a href="https://weekly.75team.com/" title="奇舞周刊" target="_blank">奇舞周刊</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">mjd507.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>