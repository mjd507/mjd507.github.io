<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 内存泄漏 的解决方案 | Jiandong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-566LR096XR" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-566LR096XR');
</script><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 内存泄漏 的解决方案</h1><a id="logo" href="/.">Jiandong</a><p class="description">Stop stopping</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 内存泄漏 的解决方案</h1><div class="post-meta">2016-12-04<span> | </span><span class="category"><a href="/categories/Big-Back-End/">Big-Back-End</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">注册的监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9C%AA%E9%87%8A%E6%94%BE"><span class="toc-number">3.</span> <span class="toc-text">资源未释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">5.</span> <span class="toc-text">补充</span></a></li></ol></div></div><div class="post-content"><p>Android 内存泄漏是很有必要引起极大重视的一个话题，因为绝大部分的内存泄漏是可以避免的，如果开发者的目标只是开发出来，而不思考自己写得代码是否隐藏着风险，是否可以进一步优化，那么毫无疑问，永远无法成为高级工程师。下面我来梳理一下可能引起内存泄漏的代码以及相应的解决方案。</p>
<span id="more"></span>


<p><strong>题外话</strong><br>先穿插一句，我所在的公司 途虎养车网 一直在与 阿里巴巴 合作进行车载系统的开发，我们的 途虎养车 需要集成到 搭载 阿里云系统（ YunOS）系统里面去，车载系统上对 app 的性能要求是极其的高。阿里那边的测试妹子也是相当厉害，对内存，CPU资源占用 这一块一直严控。我就结合着自己的项目的内存泄漏点来理一理。</p>
<h2 id="注册的监听器"><a href="#注册的监听器" class="headerlink" title="注册的监听器"></a>注册的监听器</h2><p>一般的 view.setOnClickListener(this) 并不会造成内存泄漏，因为 view 与 Activity 紧紧绑在一起，当 Activity 销毁的时候，这些 listener 会成为 garbage，垃圾回收器会随时回收它们。但是有一种情况，比如使用了单例模式来提供注册监听器，由于单例创建后一直存在在系统中，如果没有解注册监听器，那么会一直持有引用，从而导致内存泄漏。系统的 LocationManager 也是一个道理，看下面一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaksActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">LocationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_leaks);</span><br><span class="line">        locationManager = (LocationManager) <span class="keyword">this</span>.getSystemService(LOCATION_SERVICE);</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,</span><br><span class="line">                TimeUnit.MINUTES.toMillis(<span class="number">5</span>), <span class="number">100</span>, LeaksActivity.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listener implementation omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用了 Android 系统的位置更新服务，让 Activity 实现了 LocationListener 接口，并重写了它的回调方法。这样系统持有的 LocationListener 就持有了 Activity 的引用。当 Activity 可以旋转 或者 频繁的进入关闭该 Activity 的时候，由于 LocationListener 持有 引用，所以 垃圾回收器并不会回收该 Activity，从而导致了 内存泄漏。重复操作，最终将内存溢出。解决的办法就是在 onDestroy() 方法里移除更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    locationManager.removeUpdates(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外 动态注册 Broadcastreceiver 与此同理，不要忘了 unregister 。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类用起来太方便了，代码可读性也好，但是使用的时候务必谨慎一下，之所以用起来舒服，是因为内部类隐式地持有了外部类的引用，因此可以访问外部类的成员和方法，但是当内部类是一个 Thread 或者 AnsynTask 的时候，由于 Thread 执行任务 结束的时间是不确定的，当任务没有执行完时，线程是不会被销毁的，因此 它隐式引用的 Activity 也不会销毁。如果是 AnsyncTask 的情况更加糟糕，它的内部 维护了一个 ThreadPoolExecutor，该类创建的线程 的 生命周期是不确定的，或者说是无法控制的，因此更加容易出现内存泄漏。看下面一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_async);</span><br><span class="line">        textView = (TextView) findViewById(R.id.text_view);</span><br><span class="line">        <span class="keyword">new</span> BackgroundTask().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>,<span class="title">Void</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;some str&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(s);</span><br><span class="line">            textView.setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这段代码，如果是一个 HTTP 请求的话，假设网络不是很好（这个概率是很大的），由于 AsyncTask 又没有取消，哈哈，完蛋了！<br>如何解决呢？</p>
<ol>
<li>将内部类声明成静态 static 的，削除对外部类的引用。那如何获取 textView 呢？</li>
<li>在静态内部类内部保存一个 Context 的引用。思考：是否有问题？static –&gt; Context ?</li>
<li>用 弱引用 的形式 保存 Context 的引用。</li>
<li>onDestroy() 时 取消 AsyncTask。 参见 <a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask Document</a><br>修改后代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> AsyncTask&lt;Void, Void, String&gt; task;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_async);</span><br><span class="line">        textView = (TextView) findViewById(R.id.text_view);</span><br><span class="line">        task = <span class="keyword">new</span> BackgroundTask(<span class="keyword">this</span>).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>,<span class="title">Void</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; mContext;</span><br><span class="line">        BackgroundTask(Context context)&#123;</span><br><span class="line">            <span class="keyword">this</span>.mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;some str&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(s);</span><br><span class="line">            AsyncActivity activity = (AsyncActivity) mContext.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">                activity.textView.setText(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.cancel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
匿名类和内部类一样，同样持有外部类的引用，解决方法和上面相同。我们在 用 Handler 的时候，声明在内部时经常会看到编辑器会有警告 <strong>“handler should be static, else it is prone to memory leaks. ”</strong> 与上面同理。</li>
</ol>
<h2 id="资源未释放"><a href="#资源未释放" class="headerlink" title="资源未释放"></a>资源未释放</h2><p>代码里长期保持着资源的引用，比如 Context，IO 流，Cursor，Bitmap 等。资源得不到释放，从而导致泄漏。看下面 Android 官方文档的一段关于 context 的长期引用例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(state);</span><br><span class="line">  </span><br><span class="line">  TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">  label.setText(<span class="string">&quot;Leaks are bad&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sBackground = getDrawable(R.drawable.large_bitmap);</span><br><span class="line">  &#125;</span><br><span class="line">  label.setBackgroundDrawable(sBackground);</span><br><span class="line">  </span><br><span class="line">  setContentView(label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sBackground 与 TextView 关联起来了，而且 sBackground 是一个 静态 的成员变量，所以即使 activity 销毁，sBackground 仍然持有 TextView 的引用，TextView 是包含 Context 引用的，所以 最终 activity 并没有释放。<br>解决方案：</p>
<ol>
<li>尽量避免 static 关键字 引用资源消费过多的实例。</li>
<li>尽量使用 ApplicationContext，它的生命周期长，不会出现泄漏的情况。</li>
</ol>
<p>再举一个 Cursor 不关的例子。<br>我们的项目有一个单独地跑在后端的 service 进程，每 30s 去获取 阿里提供的天气数据，从而刷新洗车指数等。其中 读取天气指数 是通过读取阿里提供的本地数据库数据实现，所以用到了 Cursor，而且一直没关（不知道谁写的了，找出来绝对要面批），阿里测试反馈了这个bug，我跟进代码才揪出来，游标没关，丢人。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android Performance Patterns</a> on YouTube<br><a target="_blank" rel="noopener" href="https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.nsm8z3164">Memory leaks in Android — identify, treat and avoid</a><br><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/5002589/memory-leakage-in-event-listener">Memory leakage in event listener</a><br><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/3346080/android-references-to-a-context-and-memory-leaks">Android : References to a Context and memory leaks</a></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><p>第三方库 检测内存泄漏<br><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">LeakCanary</a> 内存泄漏检测的一个库</p>
</li>
<li><p>使用 工具 检测内存泄漏<br><a target="_blank" rel="noopener" href="http://wetest.qq.com/lab/view/?id=99&from=ads_test2_qqtips&sessionUserType=BFT.PARAMS.192844.TASKID&ADUIN=836240219&ADSESSION=1466394985&ADTAG=CLIENT.QQ.5467_.0&ADPUBNO=26558">基于Android Studio的内存泄漏检测与解决全攻略</a><br><a target="_blank" rel="noopener" href="http://wetest.qq.com/lab/view/63.html?from=ads_test2_qqtips&sessionUserType=BFT.PARAMS.195040.TASKID&ADUIN=836240219&ADSESSION=1468559577&ADTAG=CLIENT.QQ.5449_.0&ADPUBNO=26525">Android Activity泄漏问题解决方案</a><br><a target="_blank" rel="noopener" href="http://johnnyshieh.github.io/android/2016/11/18/android-memory-leak/">Android性能优化之内存泄漏</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/aaa2832/article/details/19419679/">内存分析工具 MAT 的使用</a></p>
</li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>Android 内存泄漏 的解决方案</p><p><span>Author: </span>Jiandong</p><p><span>Date: </span>2016-12-04</p><p><span>Last Update: </span>2025-02-23</p><p><span>Blog Link: </span><a href="/2016/12/04/Android-memory-leak/">https://mjd507.github.io/2016/12/04/Android-memory-leak/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://mjd507.github.io/2016/12/04/Android-memory-leak/"></i></span></p><p><span>Copyright Declaration: </span>Please refer carefully, most of the content I have not fully mastered.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2016/12/06/AsyncTask-Source-Code/">AsyncTask 源码解读</a><a class="next" href="/2016/11/30/Android-thread-pool/">说说线程池</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Back-End/">Big-Back-End</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Front-End/">Big-Front-End</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://dashaun.com/posts/" title="DaShaun Carter" target="_blank">DaShaun Carter</a><ul></ul><a href="https://develotters.com/" title="develotters" target="_blank">develotters</a><ul></ul><a href="https://vladmihalcea.com/blog/" title="Vlad Mihalcea" target="_blank">Vlad Mihalcea</a><ul></ul><a href="https://www.danvega.dev/blog/" title="Dan Vega" target="_blank">Dan Vega</a><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://www.techtalksweekly.io/" title="Tech Talks Weekly" target="_blank">Tech Talks Weekly</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Jiandong.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>